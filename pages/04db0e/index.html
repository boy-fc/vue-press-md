<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>3_Vue2 | OrangeWind</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="学习 复习 面试">
    
    <link rel="preload" href="/vue-press-md/assets/css/0.styles.80c6c626.css" as="style"><link rel="preload" href="/vue-press-md/assets/js/app.b27cc345.js" as="script"><link rel="preload" href="/vue-press-md/assets/js/2.ab91b6d3.js" as="script"><link rel="preload" href="/vue-press-md/assets/js/36.b36ff0af.js" as="script"><link rel="prefetch" href="/vue-press-md/assets/js/10.410fb8f6.js"><link rel="prefetch" href="/vue-press-md/assets/js/11.a512fa58.js"><link rel="prefetch" href="/vue-press-md/assets/js/12.36d14a37.js"><link rel="prefetch" href="/vue-press-md/assets/js/13.b2cf53bb.js"><link rel="prefetch" href="/vue-press-md/assets/js/14.e305c33b.js"><link rel="prefetch" href="/vue-press-md/assets/js/15.78466717.js"><link rel="prefetch" href="/vue-press-md/assets/js/16.62477d3a.js"><link rel="prefetch" href="/vue-press-md/assets/js/17.1c97366e.js"><link rel="prefetch" href="/vue-press-md/assets/js/18.b9034d8c.js"><link rel="prefetch" href="/vue-press-md/assets/js/19.c60b10a8.js"><link rel="prefetch" href="/vue-press-md/assets/js/20.85b8b653.js"><link rel="prefetch" href="/vue-press-md/assets/js/21.2ccb312a.js"><link rel="prefetch" href="/vue-press-md/assets/js/22.296062af.js"><link rel="prefetch" href="/vue-press-md/assets/js/23.607464eb.js"><link rel="prefetch" href="/vue-press-md/assets/js/24.aa255b94.js"><link rel="prefetch" href="/vue-press-md/assets/js/25.62cb1bb1.js"><link rel="prefetch" href="/vue-press-md/assets/js/26.0aa72996.js"><link rel="prefetch" href="/vue-press-md/assets/js/27.5effdc96.js"><link rel="prefetch" href="/vue-press-md/assets/js/28.798cbf6a.js"><link rel="prefetch" href="/vue-press-md/assets/js/29.928791fa.js"><link rel="prefetch" href="/vue-press-md/assets/js/3.fb28e9ff.js"><link rel="prefetch" href="/vue-press-md/assets/js/30.260cb155.js"><link rel="prefetch" href="/vue-press-md/assets/js/31.8a1f5c43.js"><link rel="prefetch" href="/vue-press-md/assets/js/32.6e3469d7.js"><link rel="prefetch" href="/vue-press-md/assets/js/33.c1db7a1f.js"><link rel="prefetch" href="/vue-press-md/assets/js/34.f9beb24e.js"><link rel="prefetch" href="/vue-press-md/assets/js/35.ea050dc6.js"><link rel="prefetch" href="/vue-press-md/assets/js/37.83e49789.js"><link rel="prefetch" href="/vue-press-md/assets/js/38.5576d12d.js"><link rel="prefetch" href="/vue-press-md/assets/js/39.187bd986.js"><link rel="prefetch" href="/vue-press-md/assets/js/4.b7d0708f.js"><link rel="prefetch" href="/vue-press-md/assets/js/40.45164e7f.js"><link rel="prefetch" href="/vue-press-md/assets/js/41.d33f50d2.js"><link rel="prefetch" href="/vue-press-md/assets/js/5.9e2f4ca7.js"><link rel="prefetch" href="/vue-press-md/assets/js/6.c7b54f12.js"><link rel="prefetch" href="/vue-press-md/assets/js/7.5dac6305.js"><link rel="prefetch" href="/vue-press-md/assets/js/8.d6793119.js"><link rel="prefetch" href="/vue-press-md/assets/js/9.f3d242f2.js">
    <link rel="stylesheet" href="/vue-press-md/assets/css/0.styles.80c6c626.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vue-press-md/" class="home-link router-link-active"><!----> <span class="site-name">OrangeWind</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>TypeScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/pages/e7c319/" class="sidebar-link">1_安装</a></li><li><a href="/vue-press-md/pages/6c55ba/" class="sidebar-link">2_基本类型</a></li><li><a href="/vue-press-md/pages/2bc780/" class="sidebar-link">3_接口</a></li><li><a href="/vue-press-md/pages/005633/" class="sidebar-link">4_类</a></li><li><a href="/vue-press-md/pages/5e1100/" class="sidebar-link">5_函数</a></li><li><a href="/vue-press-md/pages/2bf48b/" class="sidebar-link">6_泛型</a></li><li><a href="/vue-press-md/pages/c2333c/" class="sidebar-link">7_其他</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue3快速上手</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/pages/b9888e/" class="sidebar-link">1_创建vue3项目</a></li><li><a href="/vue-press-md/pages/835280/" class="sidebar-link">2_Composition API</a></li><li><a href="/vue-press-md/pages/c4f20f/" class="sidebar-link">3_Composition API其它</a></li><li><a href="/vue-press-md/pages/8aa12e/" class="sidebar-link">4_手写组合API</a></li><li><a href="/vue-press-md/pages/25827d/" class="sidebar-link">5_新组件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>面试相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/pages/276b03/" class="sidebar-link">1_HTML、CSS相关</a></li><li><a href="/vue-press-md/pages/3e0807/" class="sidebar-link">2_JS相关</a></li><li><a href="/vue-press-md/pages/04db0e/" aria-current="page" class="active sidebar-link">3_Vue2</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-press-md/pages/0ae77b/" class="sidebar-link">4_网络安全、HTTP协议</a></li><li><a href="/vue-press-md/pages/7d684d/" class="sidebar-link">5_前端工程化</a></li><li><a href="/vue-press-md/pages/32929a/" class="sidebar-link">6_前端性能优化</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>面试手写系列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/pages/169a00/" class="sidebar-link">1_防抖节流</a></li><li><a href="/vue-press-md/pages/94a8b1/" class="sidebar-link">2_对象浅拷贝</a></li><li><a href="/vue-press-md/pages/6ed30a/" class="sidebar-link">3_对象深拷贝</a></li><li><a href="/vue-press-md/pages/b3288c/" class="sidebar-link">4_数组去重</a></li><li><a href="/vue-press-md/pages/ec5aa8/" class="sidebar-link">5_对象去重</a></li><li><a href="/vue-press-md/pages/b46fd9/" class="sidebar-link">6_数组扁平化</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>面试经典题型</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/面试经典题型/1_面试经典题型.html" class="sidebar-link">闭包、作用域等</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>面试问题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/面试问题/1_面试问题.html" class="sidebar-link">面试问题汇总</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端单元测试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/前端单元测试/1_前端单元测试.html" class="sidebar-link">前端单元测试</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>力扣算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/力扣算法/1_力扣算法.html" class="sidebar-link">力扣算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>补充</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/补充/1_补充.html" class="sidebar-link">补充</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>抓包工具</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/抓包工具/1_抓包工具.html" class="sidebar-link">抓包工具</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>通用小工具系列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/通用小工具系列/1_通用小工具系列.html" class="sidebar-link">通用小工具系列</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="vue2"><a href="#vue2" class="header-anchor">#</a> Vue2</h3> <h4 id="简述mvvm"><a href="#简述mvvm" class="header-anchor">#</a> 简述MVVM</h4> <p><strong>MVVM</strong>是<code>Model-View-ViewModel</code>缩写，也就是把<code>MVC</code>中的<code>Controller</code>演变成<code>ViewModel。</code></p> <p><code>Model</code>层代表数据模型，<code>View</code>代表UI组件，<code>ViewModel</code>是<code>View</code>和<code>Model</code>层的桥梁，数据会绑定到<code>viewModel</code>层并自动将数据渲染到页面中，视图变化的时候会通知<code>viewModel</code>层更新数据。</p> <h4 id="谈谈对vue生命周期的理解"><a href="#谈谈对vue生命周期的理解" class="header-anchor">#</a> 谈谈对vue生命周期的理解？</h4> <p>每个<code>Vue</code>实例在创建时都会经过一系列的初始化过程，<code>vue</code>的生命周期钩子，就是说在达到某一阶段或条件时去触发的函数，目的就是为了完成一些动作或者事件</p> <ul><li><code>create阶段</code>：vue实例被创建 <code>beforeCreate</code>: 创建前，此时data和methods中的数据都还没有初始化 <code>created</code>： 创建完毕，data中有值，未挂载</li> <li><code>mount阶段</code>： vue实例被挂载到真实DOM节点 <code>beforeMount</code>：可以发起服务端请求，去数据 <code>mounted</code>: 此时可以操作Dom</li> <li><code>update阶段</code>：当vue实例里面的data数据变化时，触发组件的重新渲染 <code>beforeUpdate</code> <code>updated</code></li> <li><code>destroy阶段</code>：vue实例被销毁 <code>beforeDestroy</code>：实例被销毁前，此时可以手动销毁一些方法 <code>destroyed</code></li></ul> <h4 id="computed与watch"><a href="#computed与watch" class="header-anchor">#</a> computed与watch</h4> <p><strong>watch 属性监听</strong> 是一个对象，键是需要观察的属性，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作,监听属性的变化，需要在数据变化时执行异步或开销较大的操作时使用</p> <p><strong>computed 计算属性</strong> 属性的结果会被缓存，当<code>computed</code>中的函数所依赖的属性没有发生改变的时候，那么调用当前函数的时候结果会从缓存中读取。除非依赖的响应式属性变化时才会重新计算，主要当做属性来使用 <code>computed</code>中的函数必须用<code>return</code>返回最终的结果 <code>computed</code>更高效，优先使用</p> <p><strong>使用场景</strong> <code>computed</code>：当一个属性受多个属性影响的时候使用，例：购物车商品结算功能 <code>watch</code>：当一条数据影响多条数据的时候使用，例：搜索数据</p> <h4 id="v-for中key的作用"><a href="#v-for中key的作用" class="header-anchor">#</a> v-for中key的作用</h4> <p><code>key</code>的作用主要是为了更高效的对比虚拟DOM中每个节点是否是相同节点;</p> <p><code>Vue在patch</code>过程中判断两个节点是否是相同节点,key是一个必要条件，渲染一组列表时，key往往是唯一标识，所以如果不定义key的话，<code>Vue</code>只能认为比较的两个节点是同一个，哪怕它们实际上不是，这导致了频繁更新元素，使得整个<code>patch</code>过程比较低效，影响性能;</p> <p>从源码中可以知道，Vue判断两个节点是否相同时主要判断两者的key和元素类型等，因此如果不设置key,它的值就是<code>undefined</code>，则可能永远认为这是两个相同的节点，只能去做更新操作，这造成了大量的dom更新操作，明显是不可取的。</p> <h4 id="vue组件的通信方式"><a href="#vue组件的通信方式" class="header-anchor">#</a> vue组件的通信方式</h4> <h5 id="父子组件通信"><a href="#父子组件通信" class="header-anchor">#</a> 父子组件通信</h5> <p>父-&gt;子<code>props</code>，子-&gt;父 <code>$on、$emit</code> 获取父子组件实例 <code>parent、children</code> <code>Ref</code>获取实例的方式调用组件的属性或者方法 <code>Provide、inject</code> 官方不推荐使用，但是写组件库时很常用</p> <h5 id="兄弟组件通信"><a href="#兄弟组件通信" class="header-anchor">#</a> 兄弟组件通信</h5> <p><code>Event Bus</code> 实现跨组件通信 <code>Vue.prototype.$bus = new Vue() Vuex</code></p> <h5 id="跨级组件通信"><a href="#跨级组件通信" class="header-anchor">#</a> 跨级组件通信</h5> <p><code>$attrs、$listeners</code> <code>Provide、inject</code></p> <h4 id="常用指令"><a href="#常用指令" class="header-anchor">#</a> 常用指令</h4> <ul><li>v-if：判断是否隐藏；</li> <li>v-for：数据循环出来；</li> <li>v-bind:class：绑定一个属性；</li> <li>v-model：实现双向绑定</li></ul> <h4 id="双向绑定实现原理"><a href="#双向绑定实现原理" class="header-anchor">#</a> 双向绑定实现原理</h4> <p>当一个<strong>Vue</strong>实例创建时，Vue会遍历data选项的属性，用 <strong>Object.defineProperty</strong> 将它们转为 getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。</p> <p>每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher重新计算，从而致使它关联的组件得以更新。</p> <h4 id="v-model的实现以及它的实现原理吗"><a href="#v-model的实现以及它的实现原理吗" class="header-anchor">#</a> v-model的实现以及它的实现原理吗？</h4> <ol><li><code>vue</code>中双向绑定是一个指令<code>v-model</code>，可以绑定一个动态值到视图，同时视图中变化能改变该值。<code>v-model</code>是语法糖，默认情况下相于:<code>value和@input</code>。</li> <li>使用<code>v-model</code>可以减少大量繁琐的事件处理代码，提高开发效率，代码可读性也更好</li> <li>通常在表单项上使用<code>v-model</code></li> <li>原生的表单项可以直接使用<code>v-model</code>，自定义组件上如果要使用它需要在组件内绑定value并处理输入事件</li> <li>我做过测试，输出包含<code>v-model</code>模板的组件渲染函数，发现它会被转换为value属性的绑定以及一个事件监听，事件回调函数中会做相应变量更新操作，这说明神奇魔法实际上是vue的编译器完成的。</li></ol> <h4 id="nexttick的实现"><a href="#nexttick的实现" class="header-anchor">#</a> nextTick的实现</h4> <ol><li><code>nextTick</code>是<code>Vue</code>提供的一个全局<code>API</code>,是在下次<code>DOM</code>更新循环结束之后执行延迟回调，在修改数据之后使用<code>$nextTick</code>，则可以在回调中获取更新后的<code>DOM</code>；</li> <li>Vue在更新DOM时是异步执行的。只要侦听到数据变化，<code>Vue</code>将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个<code>watcher</code>被多次触发，只会被推入到队列中-次。这种在缓冲时去除重复数据对于避免不必要的计算和<code>DOM</code>操作是非常重要的。<code>nextTick</code>方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用；</li> <li>比如，我在干什么的时候就会使用nextTick，传一个回调函数进去，在里面执行dom操作即可；</li> <li>我也有简单了解<code>nextTick</code>实现，它会在<code>callbacks</code>里面加入我们传入的函数，然后用<code>timerFunc</code>异步方式调用它们，首选的异步方式会是<code>Promise</code>。这让我明白了为什么可以在<code>nextTick</code>中看到<code>dom</code>操作结果。</li></ol> <h4 id="vnode的理解"><a href="#vnode的理解" class="header-anchor">#</a> vnode的理解</h4> <div class="language-js extra-class"><pre class="language-js"><code>vnode 虚拟<span class="token constant">DOM</span>节点 创建：
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">Vnode</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">tag</span><span class="token operator">:</span><span class="token string">'div'</span><span class="token punctuation">,</span>
        <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token string">'span'</span><span class="token punctuation">,</span>
        <span class="token literal-property property">attr</span><span class="token operator">:</span><span class="token string">''</span><span class="token punctuation">,</span>
        <span class="token literal-property property">text</span><span class="token operator">:</span><span class="token string">'你好!'</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="new-vue后整个的流程"><a href="#new-vue后整个的流程" class="header-anchor">#</a> new Vue后整个的流程</h4> <ul><li><p><code>initProxy</code>：作用域代理，拦截组件内访问其它组件的数据。</p></li> <li><p><code>initLifecycle</code>：建立父子组件关系，在当前组件实例上添加一些属性和生命周期标识。如<code>[Math Processing Error]parent,parent,refs,$children,_isMounted</code>等。</p></li> <li><p><code>initEvents</code>：对父组件传入的事件添加监听，事件是谁创建谁监听，子组件创建事件子组件监听</p></li> <li><p><code>initRender</code>：声明[Math Processing Error]slots和slots和createElement()等。</p></li> <li><p><code>initInjections</code>：注入数据，初始化inject，一般用于组件更深层次之间的通信。</p></li> <li><p><code>initState</code>：重要）数据响应式：初始化状态。很多选项初始化的汇总：data,methods,props,computed和watch。</p></li> <li><p><code>initProvide</code>：提供数据注入。</p></li></ul> <p><strong>思考：为什么先注入再提供呢？？</strong></p> <ol><li><p>首先来自祖辈的数据要和当前实例的data,等判重，相结合，所以注入数据的initInjections一定要在<code>InitState</code>的上面。</p></li> <li><p>从上面注入进来的东西在当前组件中转了一下又提供给后代了，所以注入数据也一定要在上面。</p></li></ol> <h4 id="keep-alive的实现"><a href="#keep-alive的实现" class="header-anchor">#</a> keep-alive的实现</h4> <p>作用：实现组件缓存</p> <h5 id="钩子函数"><a href="#钩子函数" class="header-anchor">#</a> 钩子函数</h5> <p><code>activated</code>组件渲染后调用
<code>deactivated</code>组件销毁后调用</p> <p>原理：<code>Vue.js</code>内部将<code>DOM</code>节点抽象成了一个个的<code>VNode</code>节点，<code>keep-alive</code>组件的缓存也是基于<code>VNode</code>节点的而不是直接存储<code>DOM</code>结构。它将满足条件<code>（pruneCache与pruneCache）</code>的组件在<code>cache</code>对象中缓存起来，在需要重新渲染的时候再将<code>vnode</code>节点从<code>cache</code>对象中取出并渲染。</p> <h5 id="配置属性"><a href="#配置属性" class="header-anchor">#</a> 配置属性</h5> <p><code>include</code> 字符串或正则表达式。只有名称匹配的组件会被缓存</p> <p><code>exclude</code> 字符串或正则表达式。任何名称匹配的组件都不会被缓存</p> <p><code>max</code> 数字、最多可以缓存多少组件实例</p> <h4 id="vuex实现原理"><a href="#vuex实现原理" class="header-anchor">#</a> vuex实现原理</h4> <p>目标：</p> <ul><li>1.作为插件一定有install方法，可以在其中进行混入，当Vue实例化后挂载前拿到给其配置的store实例，把store放在原型上，以便全局可用；</li> <li>2.持有基本的state,保存实例化router时配置的mutations,actions对象；</li> <li>3.实现commit及dispatch等方法，可对state进行一定的修改；</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> Vue<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Store</span> <span class="token punctuation">{</span>
    <span class="token comment">// 持有state，并使其响应化</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            <span class="token literal-property property">data</span><span class="token operator">:</span>options<span class="token punctuation">.</span>state
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>mutations <span class="token operator">=</span> options<span class="token punctuation">.</span>mutations<span class="token punctuation">;</span><span class="token comment">// mutations 是对象</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>actions <span class="token operator">=</span> options<span class="token punctuation">.</span>actions<span class="token punctuation">;</span><span class="token comment">// mutations 是对象</span>
        <span class="token comment">// 绑定this</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>commit<span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>dispatch<span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 实现commit和dispatch方法</span>
    <span class="token function">commit</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span>arg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>mutations<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">,</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span>arg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>actions<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>actions<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arg<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">install</span><span class="token punctuation">(</span><span class="token parameter">_vue</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    Vue <span class="token operator">=</span> _vue<span class="token punctuation">;</span>
    <span class="token comment">// 为什么用混入？use是先执行，而this指向的是vue实例，是在main.js中后创建的，使用混入才能在vue实例的指定周期里拿到store实例并做些事情</span>
    Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token function">beforeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$options<span class="token punctuation">.</span>store<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$store<span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">.</span>$options<span class="token punctuation">.</span>store<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    Store<span class="token punctuation">,</span>
    install
<span class="token punctuation">}</span>

</code></pre></div><p>其实，Vuex.Store是个类，使用他的时候，你给他传入了参数（state，mutations，actions）并让他实例化。你把这个实例配置给了Vue，Vuex帮你把他给了Vue原型上的$store。</p> <p>Vuex还送给你个commit和dispatch方法让你能有办法改$store.state，当然你也能通过$store.state方法到你要的状态。</p> <h4 id="vue-router实现原理"><a href="#vue-router实现原理" class="header-anchor">#</a> vue-router实现原理</h4> <h5 id="hash-实现"><a href="#hash-实现" class="header-anchor">#</a> hash 实现</h5> <p>hash 是 URL 中 hash (#) 及后面的那部分，常用作锚点在页面内进行导航，<strong>改变 URL 中的 hash 部分不会引起页面刷新</strong></p> <p>通过 hashchange 事件监听 URL 的变化，改变 URL 的方式只有这几种：</p> <ol><li>通过浏览器前进后退改变 URL</li> <li>通过<code>&lt;a&gt;</code>标签改变 URL</li> <li>通过window.location改变URL</li></ol> <h5 id="history-实现"><a href="#history-实现" class="header-anchor">#</a> history 实现</h5> <p>history 提供了 pushState 和 replaceState 两个方法，<strong>这两个方法改变 URL 的 path 部分不会引起页面刷新</strong></p> <p>history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：</p> <ol><li>通过浏览器前进后退改变 URL 时会触发 popstate 事件</li> <li>通过pushState/replaceState或<code>&lt;a&gt;</code>标签改变 URL 不会触发 popstate 事件。</li> <li>好在我们可以拦截 pushState/replaceState的调用和<code>&lt;a&gt;</code>标签的点击事件来检测 URL 变化</li> <li>通过js 调用history的back，go，forward方法课触发该事件</li></ol> <p>所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。</p> <p><strong><code>$route</code>和<code>$router</code>有什么区别？</strong></p> <p><code>$router</code>是VueRouter的实例对象，<code>$route</code>是当前路由对象，也就是说<code>$route</code>是<code>$router</code>的一个属性</p> <h4 id="父组件和子组件的"><a href="#父组件和子组件的" class="header-anchor">#</a> <strong>父组件和子组件的</strong></h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//myVueRouter.js</span>
<span class="token keyword">let</span> Vue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">HistoryRoute</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">VueRouter</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>mode <span class="token operator">=</span> options<span class="token punctuation">.</span>mode <span class="token operator">||</span> <span class="token string">&quot;hash&quot;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>routes <span class="token operator">=</span> options<span class="token punctuation">.</span>routes <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">//你传递的这个路由是一个数组表</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>routesMap <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createMap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>routes<span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HistoryRoute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token punctuation">}</span>
    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mode <span class="token operator">===</span> <span class="token string">&quot;hash&quot;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">// 先判断用户打开时有没有hash值，没有的话跳转到#/</span>
            location<span class="token punctuation">.</span>hash<span class="token operator">?</span> <span class="token string">''</span><span class="token operator">:</span>location<span class="token punctuation">.</span>hash <span class="token operator">=</span> <span class="token string">&quot;/&quot;</span><span class="token punctuation">;</span>
            window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;load&quot;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>history<span class="token punctuation">.</span>current <span class="token operator">=</span> location<span class="token punctuation">.</span>hash<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
            window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;hashchange&quot;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>history<span class="token punctuation">.</span>current <span class="token operator">=</span> location<span class="token punctuation">.</span>hash<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>
            location<span class="token punctuation">.</span>pathname<span class="token operator">?</span> <span class="token string">''</span><span class="token operator">:</span>location<span class="token punctuation">.</span>pathname <span class="token operator">=</span> <span class="token string">&quot;/&quot;</span><span class="token punctuation">;</span>
            window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'load'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>history<span class="token punctuation">.</span>current <span class="token operator">=</span> location<span class="token punctuation">.</span>pathname
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
            window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;popstate&quot;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>history<span class="token punctuation">.</span>current <span class="token operator">=</span> location<span class="token punctuation">.</span>pathname
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">createMap</span><span class="token punctuation">(</span><span class="token parameter">routes</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> routes<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">pre<span class="token punctuation">,</span>current</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            pre<span class="token punctuation">[</span>current<span class="token punctuation">.</span>path<span class="token punctuation">]</span> <span class="token operator">=</span> current<span class="token punctuation">.</span>component
            <span class="token keyword">return</span> pre<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
VueRouter<span class="token punctuation">.</span><span class="token function-variable function">install</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Vue <span class="token operator">=</span> v<span class="token punctuation">;</span>
    Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token function">beforeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$options <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$options<span class="token punctuation">.</span>router<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 如果是根组件</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>_root <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">//把当前实例挂载到_root上</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>_router <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$options<span class="token punctuation">.</span>router<span class="token punctuation">;</span>
                Vue<span class="token punctuation">.</span>util<span class="token punctuation">.</span><span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token string">&quot;xxx&quot;</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>_router<span class="token punctuation">.</span>history<span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">//如果是子组件</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>_root<span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$parent <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$parent<span class="token punctuation">.</span>_root
            <span class="token punctuation">}</span>
            Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token string">'$router'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
                <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_root<span class="token punctuation">.</span>_router
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token string">'$route'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
                <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_root<span class="token punctuation">.</span>_router<span class="token punctuation">.</span>history<span class="token punctuation">.</span>current
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'router-link'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
        <span class="token literal-property property">props</span><span class="token operator">:</span><span class="token punctuation">{</span>
            <span class="token literal-property property">to</span><span class="token operator">:</span>String
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">let</span> mode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_self<span class="token punctuation">.</span>_root<span class="token punctuation">.</span>_router<span class="token punctuation">.</span>mode<span class="token punctuation">;</span>
            <span class="token keyword">let</span> to <span class="token operator">=</span> mode <span class="token operator">===</span> <span class="token string">&quot;hash&quot;</span><span class="token operator">?</span><span class="token string">&quot;#&quot;</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>to<span class="token operator">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>to
            <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token literal-property property">attrs</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token literal-property property">href</span><span class="token operator">:</span>to<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>$slots<span class="token punctuation">.</span>default<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'router-view'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
        <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">let</span> current <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_self<span class="token punctuation">.</span>_root<span class="token punctuation">.</span>_router<span class="token punctuation">.</span>history<span class="token punctuation">.</span>current
            <span class="token keyword">let</span> routeMap <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_self<span class="token punctuation">.</span>_root<span class="token punctuation">.</span>_router<span class="token punctuation">.</span>routesMap<span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>routeMap<span class="token punctuation">[</span>current<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> VueRouter

</code></pre></div><h4 id="执行顺序"><a href="#执行顺序" class="header-anchor">#</a> <strong>执行顺序</strong>？</h4> <p>父beforeCreate-&gt; 父created -&gt; 父beforeMounte -&gt; 子beforeCreate -&gt;子create -&gt;子beforeMount -&gt;子 mounted -&gt; 父mounted</p> <h4 id="diff算法简单理解"><a href="#diff算法简单理解" class="header-anchor">#</a> diff算法简单理解</h4> <p>在js中,渲染真实<code>DOM</code>的开销是非常大的, 比如我们修改了某个数据,如果直接渲染到真实<code>DOM</code>, 会引起整个<code>dom</code>树的重绘和重排。那么有没有可能实现只更新我们修改的那一小块dom而不要更新整个<code>dom</code>呢？此时我们就需要先根据真实<code>dom</code>生成虚拟<code>dom</code>， 当虚拟<code>dom</code>某个节点的数据改变后会生成有一个新的<code>Vnode</code>, 然后新的<code>Vnode</code>和旧的<code>Vnode</code>作比较，发现有不一样的地方就直接修改在真实DOM上，然后使旧的<code>Vnode</code>的值为新的<code>Vnode</code>。</p> <p><strong>diff</strong>的过程就是调用<code>patch</code>函数，比较新旧节点，一边比较一边给真实的<code>DOM</code>打补丁。在采取<code>diff</code>算法比较新旧节点的时候，比较只会在同层级进行。 在<code>patch</code>方法中，首先进行树级别的比较 <code>new Vnode</code>不存在就删除 <code>old Vnode</code> <code>old Vnode</code> 不存在就增加新的<code>Vnode</code> 都存在就执行diff更新 当确定需要执行diff算法时，比较两个<code>Vnode</code>，包括三种类型操作：属性更新，文本更新，子节点更新 新老节点均有子节点，则对子节点进行<code>diff</code>操作，调用<code>updatechidren</code> 如果老节点没有子节点而新节点有子节点，先清空老节点的文本内容，然后为其新增子节点 如果新节点没有子节点，而老节点有子节点的时候，则移除该节点的所有子节点 老新老节点都没有子节点的时候，进行文本的替换</p> <p><strong>updateChildren</strong> 将<code>Vnode</code>的子节点Vch和oldVnode的子节点oldCh提取出来。 <code>oldCh和vCh</code>各有两个头尾的变量<code>StartIdx和EndIdx</code>，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了<code>key</code>，就会用<code>key</code>进行比较，在比较的过程中，变量会往中间靠，一旦<code>StartIdx&gt;EndIdx</code>表明<code>oldCh和vCh</code>至少有一个已经遍历完了，就会结束比较。</p> <h4 id="你都做过哪些vue的性能优化"><a href="#你都做过哪些vue的性能优化" class="header-anchor">#</a> 你都做过哪些Vue的性能优化？</h4> <div class="language-js extra-class"><pre class="language-js"><code>编码阶段
尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher
v<span class="token operator">-</span><span class="token keyword">if</span>和v<span class="token operator">-</span><span class="token keyword">for</span>不能连用
如果需要使用v<span class="token operator">-</span><span class="token keyword">for</span>给每项元素绑定事件时使用事件代理
<span class="token constant">SPA</span> 页面采用keep<span class="token operator">-</span>alive缓存组件
在更多的情况下，使用v<span class="token operator">-</span><span class="token keyword">if</span>替代v<span class="token operator">-</span>show
key保证唯一
使用路由懒加载、异步组件
防抖、节流
第三方模块按需导入
长列表滚动到可视区域动态加载
图片懒加载
<span class="token constant">SEO</span>优化
预渲染
服务端渲染<span class="token constant">SSR</span>
打包优化
压缩代码
Tree Shaking<span class="token operator">/</span>Scope Hoisting
使用cdn加载第三方模块
多线程打包happypack
splitChunks抽离公共文件
sourceMap优化
用户体验
骨架屏
<span class="token constant">PWA</span>
<span class="token function">还可以使用缓存</span><span class="token punctuation">(</span>客户端缓存、服务端缓存<span class="token punctuation">)</span>优化、服务端开启gzip压缩等。

</code></pre></div><h4 id="vue3有新特性"><a href="#vue3有新特性" class="header-anchor">#</a> Vue3有新特性</h4> <ul><li><strong>性能提升</strong></li></ul> <p>更小巧、更快速 支持自定义渲染器 支持摇树优化：一种在打包时去除无用代码的优化手段 支持Fragments和跨组件渲染</p> <ul><li><strong>API变动</strong></li></ul> <p>模板语法99%保持不变 原生支持基于class的组件，并且无需借助任何编译及各种stage阶段的特性 在设计时也考虑TypeScript的类型推断特性 <code>重写虚拟DOM</code>可以期待更多的编译时提示来减少运行时的开销 <code>优化插槽生成</code>可以单独渲染父组件和子组件 <code>静态树提升</code>降低渲染成本 <code>基于Proxy的观察者机制</code>节省内存开销</p> <ul><li><strong>不兼容IE11</strong></li></ul> <p><code>检测机制</code>更加全面、精准、高效,更具可调试式的响应跟踪</p> <h4 id="proxy与object-defineproperty相比"><a href="#proxy与object-defineproperty相比" class="header-anchor">#</a> Proxy与Object.defineProperty相比</h4> <ol><li><strong>Object.definedProperty</strong>的作用是劫持一个对象的属性，劫持属性的getter和setter方法，在对象的属性发生变化时进行特定的操作。而Proxy劫持的是整个对象。</li> <li><strong>Proxy</strong>会返回一个代理对象，我们只需要操作新对象即可，而Object.defineProperty只能遍历对象属性直接修改。</li> <li><strong>Object.definedProperty</strong>不支持数组，更准确的说是不支持数组的各种API，因为如果仅仅考虑arry[i] = value 这种情况，是可以劫持的，但是这种劫持意义不大。而Proxy可以支持数组的各种API。</li> <li>尽管Object.defineProperty有诸多缺陷，但是其兼容性要好于Proxy。</li></ol> <h4 id="vue与react对比"><a href="#vue与react对比" class="header-anchor">#</a> Vue与React对比</h4> <p><strong>react</strong>主张函数式编程，所以推崇纯组件，数据不可变，单向数据流，</p> <p><strong>vue</strong>的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。</p> <p><strong>监听数据变化实现原理</strong>：</p> <ul><li><code>Vue</code> 通过 <code>getter/setter</code> 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li> <li><code>React</code> 默认是通过比较引用的方式进行的，如果不优化(<code>PureComponent/shouldComponentUpdate</code>)可能导致大量不必要的VDOM的重新渲染。</li></ul> <p>组件通信的区别：jsx和.vue模板。</p> <ul><li><code>HoC和Mixins</code>(在Vue中我们组合不同功能的方式是通过<code>Mixin</code>，而在<code>React</code>中我们通过<code>HoC</code>(高阶组件))。</li></ul> <p><strong>性能优化</strong></p> <ul><li><code>React: shouldComponentUpdate</code></li> <li><code>Vue</code>:内部实现<code>shouldComponentUpdate</code>的优化，由于依赖追踪系统存在，通过<code>watcher</code>判断是否需要重新渲染(当一个页面数据量较大时，<code>Vue</code>的性能较差，造成页面卡顿，所以一般数据比较大的项目倾向使用<code>React</code>)</li></ul> <h4 id="vuex-和-redux-之间的区别"><a href="#vuex-和-redux-之间的区别" class="header-anchor">#</a> vuex 和 redux 之间的区别？</h4> <p>从实现原理上来说，最大的区别是两点：</p> <p><strong>Redux</strong>使用的是不可变数据，而<code>Vuex</code>的数据是可变的。<code>Redux</code>每次都是用新的<code>state</code>替换旧的<code>state</code>，而<code>Vuex</code>是直接修改</p> <p><strong>Redux</strong>在检测数据变化的时候，是通过<code>diff</code>的方式比较差异的，而<code>Vuex</code>其实和Vue的原理一样，是通过 <code>getter/setter</code>来比较的(如果看<code>Vuex</code>源码会知道，其实他内部直接创建一个<code>Vue</code>实例用来跟踪数据变化)</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vue-press-md/pages/3e0807/" class="prev">
        2_JS相关
      </a></span> <span class="next"><a href="/vue-press-md/pages/0ae77b/">
        4_网络安全、HTTP协议
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vue-press-md/assets/js/app.b27cc345.js" defer></script><script src="/vue-press-md/assets/js/2.ab91b6d3.js" defer></script><script src="/vue-press-md/assets/js/36.b36ff0af.js" defer></script>
  </body>
</html>
