<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>网络安全、HTTP协议 | OrangeWind</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="学习 复习 面试">
    
    <link rel="preload" href="/vue-press-md/assets/css/0.styles.1dd70239.css" as="style"><link rel="preload" href="/vue-press-md/assets/js/app.7d3559cd.js" as="script"><link rel="preload" href="/vue-press-md/assets/js/2.ab91b6d3.js" as="script"><link rel="preload" href="/vue-press-md/assets/js/17.df8a2b49.js" as="script"><link rel="prefetch" href="/vue-press-md/assets/js/10.9a978364.js"><link rel="prefetch" href="/vue-press-md/assets/js/11.77d85d64.js"><link rel="prefetch" href="/vue-press-md/assets/js/12.34fa95a8.js"><link rel="prefetch" href="/vue-press-md/assets/js/13.7d02cd80.js"><link rel="prefetch" href="/vue-press-md/assets/js/14.92e0a39a.js"><link rel="prefetch" href="/vue-press-md/assets/js/15.bcd5d747.js"><link rel="prefetch" href="/vue-press-md/assets/js/16.b2d225e1.js"><link rel="prefetch" href="/vue-press-md/assets/js/3.546ba140.js"><link rel="prefetch" href="/vue-press-md/assets/js/4.ed8f2e2d.js"><link rel="prefetch" href="/vue-press-md/assets/js/5.32dde0b2.js"><link rel="prefetch" href="/vue-press-md/assets/js/6.c7b54f12.js"><link rel="prefetch" href="/vue-press-md/assets/js/7.f39602d3.js"><link rel="prefetch" href="/vue-press-md/assets/js/8.341b318c.js"><link rel="prefetch" href="/vue-press-md/assets/js/9.a4e7aadf.js">
    <link rel="stylesheet" href="/vue-press-md/assets/css/0.styles.1dd70239.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vue-press-md/" class="home-link router-link-active"><!----> <span class="site-name">OrangeWind</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>TypeScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/typeScript/1_安装.html" class="sidebar-link">安装</a></li><li><a href="/vue-press-md/typeScript/2_基本类型.html" class="sidebar-link">基本类型</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="网络安全、http协议"><a href="#网络安全、http协议" class="header-anchor">#</a> 网络安全、HTTP协议</h3> <h4 id="tcp-udp-区别"><a href="#tcp-udp-区别" class="header-anchor">#</a> TCP UDP 区别</h4> <p>1.<code>TCP</code>向上层提供面向连接的可靠服务 ，<code>UDP</code>向上层提供无连接不可靠服务。
2.虽然 <code>UDP</code> 并没有 <code>TCP</code> 传输来的准确，但是也能在很多实时性要求高的地方有所作为
3.对数据准确性要求高，速度可以相对较慢的，可以选用<code>TCP</code></p> <table><thead><tr><th>区别</th> <th>UDP</th> <th>TCP</th></tr></thead> <tbody><tr><td>是否连接</td> <td>无连接</td> <td>面向连接</td></tr> <tr><td>是否可靠</td> <td>不可靠传输，不使用流量控制和拥塞控制</td> <td>可靠传输，使用流量控制和拥塞控制</td></tr> <tr><td>连接对象个数</td> <td>支持一对一，一对多，多对一和多对多交互通信</td> <td>只能是一对一通信</td></tr> <tr><td>传输方式</td> <td>面向报文</td> <td>面向字节流</td></tr> <tr><td>首部开销</td> <td>首部开销小，仅8字节</td> <td>首部最小20字节，最大60字节</td></tr> <tr><td>适用场景</td> <td>适用于实时应用（IP电话、视频会议、直播等）</td> <td>适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table> <h4 id="http和https区别-高频"><a href="#http和https区别-高频" class="header-anchor">#</a> Http和Https区别（高频）</h4> <p>1.<code>HTTP</code> 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头
2.<code>HTTP</code> 是不安全的，而 HTTPS 是安全的
3.<code>HTTP</code> 标准端口是80 ，而 HTTPS 的标准端口是443
4.<code>在OSI</code> 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层
5.<code>HTTP</code> 无法加密，而HTTPS 对传输的数据进行加密
6.<code>HTTP</code>无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书</p> <h4 id="get和post区别-高频"><a href="#get和post区别-高频" class="header-anchor">#</a> GET和POST区别（高频）</h4> <p>1.GET在浏览器回退不会再次请求，POST会再次提交请求
2.GET请求会被浏览器主动缓存，POST不会，要手动设置
3.GET请求参数会被完整保留在浏览器历史记录里，POST中的参数不会
4.GET请求在URL中传送的参数是有长度限制的，而POST没有限制
5.GET参数通过URL传递，POST放在Request body中
6.GET参数暴露在地址栏不安全，POST放在报文内部更安全
7.GET一般用于查询信息，POST一般用于提交某种信息进行某些修改操作
8.GET产生一个TCP数据包；POST产生两个TCP数据包</p> <h4 id="理解xss-csrf-ddos攻击原理以及避免方式"><a href="#理解xss-csrf-ddos攻击原理以及避免方式" class="header-anchor">#</a> 理解xss，csrf，ddos攻击原理以及避免方式</h4> <p><code>XSS</code>(<code>Cross-Site Scripting</code>，<strong>跨站脚本攻击</strong>)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 <code>cookie，session tokens</code>，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。</p> <p><strong>XSS避免方式：</strong></p> <ol><li><p><code>url</code>参数使用<code>encodeURIComponent</code>方法转义</p></li> <li><p>尽量不是有<code>InnerHtml</code>插入<code>HTML</code>内容</p></li> <li><p>使用特殊符号、标签转义符。</p></li></ol> <p><code>CSRF</code>（<code>Cross-site request forgery</code>）<strong>跨站请求伪造</strong>：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p> <p><code>CSRF</code>避免方式：</p> <ol><li><p>添加验证码</p></li> <li><p>使用token</p> <ul><li><p>服务端给用户生成一个token，加密后传递给用户</p></li> <li><p>用户在提交请求时，需要携带这个token</p></li> <li><p>服务端验证token是否正确</p></li></ul></li></ol> <p><code>DDoS</code>又叫分布式拒绝服务，全称 <code>Distributed Denial of Service</code>，其原理就是利用大量的请求造成资源过载，导致服务不可用。</p> <p><strong><code>DDos</code>避免方式：</strong></p> <ol><li>限制单IP请求频率。</li> <li>防火墙等防护设置禁止<code>ICMP</code>包等</li> <li>检查特权端口的开放</li></ol> <h4 id="http特性以及状态码"><a href="#http特性以及状态码" class="header-anchor">#</a> http特性以及状态码</h4> <div class="language-js extra-class"><pre class="language-js"><code>比如：
    <span class="token number">200</span>响应成功
    <span class="token number">301</span>永久重定向
    <span class="token number">302</span>临时重定向
    <span class="token number">304</span>资源缓存
    <span class="token number">403</span>服务器禁止访问
    <span class="token number">404</span>服务器资源未找到
    <span class="token number">500</span> <span class="token number">502</span>服务器内部错误
    <span class="token number">504</span> 服务器繁忙
    1xx	Informational（信息状态码）	  接受请求正在处理
    2xx	Success（成功状态码）            请求正常处理完毕
    3xx	Redirection（重定向状态码）		 需要附加操作已完成请求
    4xx	Client Error（客户端错误状态码）	服务器无法处理请求
    5xx	Server Error（服务器错误状态码）	服务器处理请求出错

</code></pre></div><h4 id="http三次握手"><a href="#http三次握手" class="header-anchor">#</a> http三次握手</h4> <ul><li>第一步：客户端发送SYN报文到服务端发起握手，发送完之后客户端处于SYN_Send状态</li> <li>第二步：服务端收到SYN报文之后回复SYN和ACK报文给客户端</li> <li>第三步：客户端收到SYN和ACK，向服务端发送一个ACK报文,客户端转为established状态，此时服务端收到ACK报文后也处于established状态，此时双方已建立了连接</li></ul> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7675cb2d10834de9a07f9428ce9a427a~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p> <h4 id="http四次挥手"><a href="#http四次挥手" class="header-anchor">#</a> http四次挥手</h4> <p>刚开始双方都处于<code>establised</code> 状态，假如是客户端先发起关闭请求，则：</p> <ol><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。</li> <li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。</li> <li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li> <li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</li> <li>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li></ol> <h4 id="http1-0、http1-1、http2-0的区别"><a href="#http1-0、http1-1、http2-0的区别" class="header-anchor">#</a> http1.0、http1.1、http2.0的区别</h4> <ol><li>1和1.0相比，1.1可以一次传输多个文件</li> <li>http1.x解析基于文本，http2.0采用二进制格式，新增特性 多路复用、header压缩、服务端推送(静态html资源)</li></ol> <h4 id="http如何实现缓存"><a href="#http如何实现缓存" class="header-anchor">#</a> http如何实现缓存</h4> <p><strong>强缓存</strong>==&gt;Expires(过期时间)/Cache-Control(no-cache)(优先级高) 协商缓存 ==&gt;Last-Modified/Etag(优先级高)Etag适用于经常改变的小文件  Last-Modefied适用于不怎么经常改变的大文件</p> <p><strong>强缓存策略和协商缓存策略</strong>在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。</p> <h4 id="输入url后http请求的完整过程"><a href="#输入url后http请求的完整过程" class="header-anchor">#</a> 输入url后http请求的完整过程</h4> <p><strong>建立TCP连接-&gt;发送请求行-&gt;发送请求头-&gt;（到达服务器）发送状态行-&gt;发送响应头-&gt;发送响应数据-&gt;断TCP连接</strong></p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/vue-press-md/assets/js/app.7d3559cd.js" defer></script><script src="/vue-press-md/assets/js/2.ab91b6d3.js" defer></script><script src="/vue-press-md/assets/js/17.df8a2b49.js" defer></script>
  </body>
</html>
