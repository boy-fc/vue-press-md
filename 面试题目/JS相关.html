<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS相关 | OrangeWind</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="学习 复习 面试">
    
    <link rel="preload" href="/vue-press-md/assets/css/0.styles.1dd70239.css" as="style"><link rel="preload" href="/vue-press-md/assets/js/app.7d3559cd.js" as="script"><link rel="preload" href="/vue-press-md/assets/js/2.ab91b6d3.js" as="script"><link rel="preload" href="/vue-press-md/assets/js/13.7d02cd80.js" as="script"><link rel="prefetch" href="/vue-press-md/assets/js/10.9a978364.js"><link rel="prefetch" href="/vue-press-md/assets/js/11.77d85d64.js"><link rel="prefetch" href="/vue-press-md/assets/js/12.34fa95a8.js"><link rel="prefetch" href="/vue-press-md/assets/js/14.92e0a39a.js"><link rel="prefetch" href="/vue-press-md/assets/js/15.bcd5d747.js"><link rel="prefetch" href="/vue-press-md/assets/js/16.b2d225e1.js"><link rel="prefetch" href="/vue-press-md/assets/js/17.df8a2b49.js"><link rel="prefetch" href="/vue-press-md/assets/js/3.546ba140.js"><link rel="prefetch" href="/vue-press-md/assets/js/4.ed8f2e2d.js"><link rel="prefetch" href="/vue-press-md/assets/js/5.32dde0b2.js"><link rel="prefetch" href="/vue-press-md/assets/js/6.c7b54f12.js"><link rel="prefetch" href="/vue-press-md/assets/js/7.f39602d3.js"><link rel="prefetch" href="/vue-press-md/assets/js/8.341b318c.js"><link rel="prefetch" href="/vue-press-md/assets/js/9.a4e7aadf.js">
    <link rel="stylesheet" href="/vue-press-md/assets/css/0.styles.1dd70239.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vue-press-md/" class="home-link router-link-active"><!----> <span class="site-name">OrangeWind</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>TypeScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/typeScript/1_安装.html" class="sidebar-link">安装</a></li><li><a href="/vue-press-md/typeScript/2_基本类型.html" class="sidebar-link">基本类型</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h4 id="js相关"><a href="#js相关" class="header-anchor">#</a> JS相关</h4> <h4 id="js数据类型、typeof、instanceof、类型转换"><a href="#js数据类型、typeof、instanceof、类型转换" class="header-anchor">#</a> js数据类型、typeof、instanceof、类型转换</h4> <ol><li><code>string、number、boolean、null、undefined、object(function、array)、symbol(ES10 BigInt)</code></li> <li><code>typeof</code> 主要用来判断数据类型 返回值有<code>string、boolean、number、function、object、undefined。</code></li> <li><code>instanceof</code> 判断该对象是谁的实例</li> <li><code>null</code>表示空对象 <code>undefined</code>表示已在作用域中声明但未赋值的变量</li></ol> <h4 id="闭包-高频"><a href="#闭包-高频" class="header-anchor">#</a> 闭包(高频)</h4> <p>一个函数和对其周围状态（<strong>lexical environment，词法环境</strong>）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是<strong>闭包</strong>（<strong>closure</strong>）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&quot;Mozilla&quot;</span><span class="token punctuation">;</span> <span class="token comment">// name 是一个被 init 创建的局部变量</span>
    <span class="token keyword">function</span> <span class="token function">displayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// displayName() 是内部函数，一个闭包</span>
        <span class="token function">alert</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用了父函数中声明的变量</span>
    <span class="token punctuation">}</span>
    <span class="token function">displayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>闭包是指有权访问另一个函数作用域中的变量的函数 ——《JavaScript高级程序设计》</p> <p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，</p> <p>即使函数是在当前词法作用域之外执行 ——《你不知道的JavaScript》</p> <ul><li>闭包用途：
<ol><li>能够访问函数定义时所在的词法作用域(阻止其被回收)</li> <li>私有化变量</li> <li>模拟块级作用域</li> <li>创建模块</li></ol></li> <li>闭包缺点：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</li></ul> <h4 id="原型、原型链-高频"><a href="#原型、原型链-高频" class="header-anchor">#</a> 原型、原型链(高频)</h4> <p><strong>原型:</strong> 对象中固有的<code>__proto__</code>属性，该属性指向对象的<code>prototype</code>原型属性。</p> <p><strong>原型链:</strong> 当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是<code>Object.prototype</code>所以这就是我们新建的对象为什么能够使用<code>toString()</code>等方法的原因。</p> <p><strong>特点:</strong> <code>JavaScript</code>对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p> <p><img src="https://pic2.zhimg.com/80/v2-e722d5325f7d4215169f1d04296e0f89_1440w.jpg" alt=""></p> <h4 id="this指向、new关键字"><a href="#this指向、new关键字" class="header-anchor">#</a> this指向、new关键字</h4> <p><code>this</code>对象是是执行上下文中的一个属性，它指向最后一次调用这个方法的对象，在全局函数中，<code>this</code>等于<code>window</code>，而当函数被作为某个对象调用时，this等于那个对象。 在实际开发中，<code>this</code>的指向可以通过四种调用模式来判断。</p> <ol><li>函数调用，当一个函数不是一个对象的属性时，直接作为函数来调用时，<code>this</code>指向全局对象。</li> <li>方法调用，如果一个函数作为一个对象的方法来调用时，<code>this</code>指向这个对象。</li> <li>构造函数调用，<code>this</code>指向这个用<code>new</code>新创建的对象。</li> <li>第四种是 <code>apply 、 call 和 bind</code>调用模式，这三个方法都可以显示的指定调用函数的 this 指向。<code>apply</code>接收参数的是数组，<code>call</code>接受参数列表，<code>bind</code>方法通过传入一个对象，返回一个<code>this</code>绑定了传入对象的新函数。这个函数的 <code>this</code>指向除了使用<code>new</code>时会被改变，其他情况下都不会改变。</li></ol> <p><strong>new</strong></p> <ol><li>首先创建了一个新的空对象</li> <li>设置原型，将对象的原型设置为函数的<code>prototype</code>对象。</li> <li>让函数的<code>this</code>指向这个对象，执行构造函数的代码（为这个新对象添加属性）</li> <li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li></ol> <h4 id="作用域、作用域链、变量提升"><a href="#作用域、作用域链、变量提升" class="header-anchor">#</a> 作用域、作用域链、变量提升</h4> <p><code>作用域</code>负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。(全局作用域、函数作用域、块级作用域)。 作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是<code>作用域链</code>。</p> <h4 id="继承-含es6-、多种继承方式"><a href="#继承-含es6-、多种继承方式" class="header-anchor">#</a> 继承(含es6)、多种继承方式</h4> <p>（1）第一种是以<code>原型链的方式来实现继承</code>，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</p> <p>（2）第二种方式是使用<code>借用构造函数</code>的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</p> <p>（3）第三种方式是<code>组合继承</code>，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</p> <p>（4）第四种方式是<code>原型式继承</code>，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</p> <p>（5）第五种方式是<code>寄生式继承</code>，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。</p> <p>（6）第六种方式是<code>寄生式组合继承</code>，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</p> <h4 id="eventloop"><a href="#eventloop" class="header-anchor">#</a> <strong>EventLoop</strong></h4> <p><code>JS</code>是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。</p> <p>微任务队列的代表就是，<code>Promise.then</code>，<code>MutationObserver</code></p> <p>宏任务的话就是<code>setImmediate setTimeout setInterval</code></p> <h4 id="原生ajax"><a href="#原生ajax" class="header-anchor">#</a> 原生ajax</h4> <p><strong>ajax</strong>是一种异步通信的方法,从服务端获取数据,达到局部刷新页面的效果。 过程：</p> <ol><li>创建<code>XMLHttpRequest</code>对象;</li> <li>调用<code>open</code>方法传入三个参数 请求方式<code>(GET/POST)、url、同步异步(true/false)</code>;</li> <li>监听<code>onreadystatechange</code>事件，当<code>readystate</code>等于4时返回<code>responseText</code>;</li> <li>调用send方法传递参数。</li></ol> <h4 id="事件冒泡、捕获-委托"><a href="#事件冒泡、捕获-委托" class="header-anchor">#</a> 事件冒泡、捕获(委托)</h4> <ul><li><strong>事件冒泡</strong>指在一个对象上触发某类事件，如果此对象绑定了事件，就会触发事件，如果没有，就会向这个对象的父级对象传播，最终父级对象触发了事件。</li> <li><strong>事件委托</strong>本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为<strong>事件代理</strong>。</li></ul> <p><code>event.stopPropagation()</code> 或者 ie下的方法 <code>event.cancelBubble = true;</code> //阻止事件冒泡</p> <h4 id="es6"><a href="#es6" class="header-anchor">#</a> ES6</h4> <p>新增symbol类型 表示独一无二的值，用来定义独一无二的对象属性名;</p> <p>const/let  都是用来声明变量,不可重复声明，具有块级作用域。存在暂时性死区，也就是不存在变量提升。(const一般用于声明常量);</p> <p>变量的解构赋值(包含数组、对象、字符串、数字及布尔值,函数参数),剩余运算符(...rest);</p> <p>模板字符串(<code>${data}</code>);</p> <p>扩展运算符(数组、对象);;</p> <p>箭头函数;</p> <p>Set和Map数据结构;</p> <p>Proxy/Reflect;</p> <p>Promise;</p> <p>async函数;</p> <p>Class;</p> <p>Module语法(import/export)。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/vue-press-md/assets/js/app.7d3559cd.js" defer></script><script src="/vue-press-md/assets/js/2.ab91b6d3.js" defer></script><script src="/vue-press-md/assets/js/13.7d02cd80.js" defer></script>
  </body>
</html>
