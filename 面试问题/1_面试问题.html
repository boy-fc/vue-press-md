<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试问题汇总 | OrangeWind</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="学习 复习 面试">
    
    <link rel="preload" href="/vue-press-md/assets/css/0.styles.1dd70239.css" as="style"><link rel="preload" href="/vue-press-md/assets/js/app.14c5cd4c.js" as="script"><link rel="preload" href="/vue-press-md/assets/js/2.ab91b6d3.js" as="script"><link rel="preload" href="/vue-press-md/assets/js/41.8261988b.js" as="script"><link rel="prefetch" href="/vue-press-md/assets/js/10.410fb8f6.js"><link rel="prefetch" href="/vue-press-md/assets/js/11.a512fa58.js"><link rel="prefetch" href="/vue-press-md/assets/js/12.36d14a37.js"><link rel="prefetch" href="/vue-press-md/assets/js/13.b2cf53bb.js"><link rel="prefetch" href="/vue-press-md/assets/js/14.e305c33b.js"><link rel="prefetch" href="/vue-press-md/assets/js/15.2f9b399c.js"><link rel="prefetch" href="/vue-press-md/assets/js/16.62477d3a.js"><link rel="prefetch" href="/vue-press-md/assets/js/17.91349d99.js"><link rel="prefetch" href="/vue-press-md/assets/js/18.1247f683.js"><link rel="prefetch" href="/vue-press-md/assets/js/19.7abd9697.js"><link rel="prefetch" href="/vue-press-md/assets/js/20.52d319e7.js"><link rel="prefetch" href="/vue-press-md/assets/js/21.2ccb312a.js"><link rel="prefetch" href="/vue-press-md/assets/js/22.296062af.js"><link rel="prefetch" href="/vue-press-md/assets/js/23.607464eb.js"><link rel="prefetch" href="/vue-press-md/assets/js/24.5dbb7968.js"><link rel="prefetch" href="/vue-press-md/assets/js/25.62cb1bb1.js"><link rel="prefetch" href="/vue-press-md/assets/js/26.881f9eea.js"><link rel="prefetch" href="/vue-press-md/assets/js/27.69afc405.js"><link rel="prefetch" href="/vue-press-md/assets/js/28.a0281f21.js"><link rel="prefetch" href="/vue-press-md/assets/js/29.6c005520.js"><link rel="prefetch" href="/vue-press-md/assets/js/3.fb28e9ff.js"><link rel="prefetch" href="/vue-press-md/assets/js/30.260cb155.js"><link rel="prefetch" href="/vue-press-md/assets/js/31.8a1f5c43.js"><link rel="prefetch" href="/vue-press-md/assets/js/32.6e3469d7.js"><link rel="prefetch" href="/vue-press-md/assets/js/33.c1db7a1f.js"><link rel="prefetch" href="/vue-press-md/assets/js/34.60454519.js"><link rel="prefetch" href="/vue-press-md/assets/js/35.ea050dc6.js"><link rel="prefetch" href="/vue-press-md/assets/js/36.ba38a54b.js"><link rel="prefetch" href="/vue-press-md/assets/js/37.0b687a07.js"><link rel="prefetch" href="/vue-press-md/assets/js/38.9985455b.js"><link rel="prefetch" href="/vue-press-md/assets/js/39.c727caa6.js"><link rel="prefetch" href="/vue-press-md/assets/js/4.ed8f2e2d.js"><link rel="prefetch" href="/vue-press-md/assets/js/40.45164e7f.js"><link rel="prefetch" href="/vue-press-md/assets/js/5.32dde0b2.js"><link rel="prefetch" href="/vue-press-md/assets/js/6.c7b54f12.js"><link rel="prefetch" href="/vue-press-md/assets/js/7.b10070a8.js"><link rel="prefetch" href="/vue-press-md/assets/js/8.d6793119.js"><link rel="prefetch" href="/vue-press-md/assets/js/9.1d36f099.js">
    <link rel="stylesheet" href="/vue-press-md/assets/css/0.styles.1dd70239.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vue-press-md/" class="home-link router-link-active"><!----> <span class="site-name">OrangeWind</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>TypeScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/pages/e7c319/" class="sidebar-link">1_安装</a></li><li><a href="/vue-press-md/pages/6c55ba/" class="sidebar-link">2_基本类型</a></li><li><a href="/vue-press-md/pages/2bc780/" class="sidebar-link">3_接口</a></li><li><a href="/vue-press-md/pages/005633/" class="sidebar-link">4_类</a></li><li><a href="/vue-press-md/pages/5e1100/" class="sidebar-link">5_函数</a></li><li><a href="/vue-press-md/pages/2bf48b/" class="sidebar-link">6_泛型</a></li><li><a href="/vue-press-md/pages/c2333c/" class="sidebar-link">7_其他</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue3快速上手</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/pages/b9888e/" class="sidebar-link">1_创建vue3项目</a></li><li><a href="/vue-press-md/pages/835280/" class="sidebar-link">2_Composition API</a></li><li><a href="/vue-press-md/pages/c4f20f/" class="sidebar-link">3_Composition API其它</a></li><li><a href="/vue-press-md/pages/8aa12e/" class="sidebar-link">4_手写组合API</a></li><li><a href="/vue-press-md/pages/25827d/" class="sidebar-link">5_新组件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>面试相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/pages/276b03/" class="sidebar-link">1_HTML、CSS相关</a></li><li><a href="/vue-press-md/pages/3e0807/" class="sidebar-link">2_JS相关</a></li><li><a href="/vue-press-md/pages/04db0e/" class="sidebar-link">3_Vue2</a></li><li><a href="/vue-press-md/pages/0ae77b/" class="sidebar-link">4_网络安全、HTTP协议</a></li><li><a href="/vue-press-md/pages/7d684d/" class="sidebar-link">5_前端工程化</a></li><li><a href="/vue-press-md/pages/32929a/" class="sidebar-link">6_前端性能优化</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>面试手写系列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/pages/169a00/" class="sidebar-link">1_防抖节流</a></li><li><a href="/vue-press-md/pages/94a8b1/" class="sidebar-link">2_对象浅拷贝</a></li><li><a href="/vue-press-md/pages/6ed30a/" class="sidebar-link">3_对象深拷贝</a></li><li><a href="/vue-press-md/pages/b3288c/" class="sidebar-link">4_数组去重</a></li><li><a href="/vue-press-md/pages/ec5aa8/" class="sidebar-link">5_对象去重</a></li><li><a href="/vue-press-md/pages/b46fd9/" class="sidebar-link">6_数组扁平化</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>面试经典题型</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/面试经典题型/1_面试经典题型.html" class="sidebar-link">闭包、作用域等</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>面试问题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/面试问题/1_面试问题.html" class="active sidebar-link">面试问题汇总</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端单元测试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/前端单元测试/1_前端单元测试.html" class="sidebar-link">前端单元测试</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>力扣算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/力扣算法/1_力扣算法.html" class="sidebar-link">力扣算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>补充</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/补充/1_补充.html" class="sidebar-link">补充</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>抓包工具</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/抓包工具/1_抓包工具.html" class="sidebar-link">抓包工具</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>通用小工具系列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/通用小工具系列/1_通用小工具系列.html" class="sidebar-link">通用小工具系列</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="面试问题汇总"><a href="#面试问题汇总" class="header-anchor">#</a> 面试问题汇总</h3> <h4 id="css"><a href="#css" class="header-anchor">#</a> CSS</h4> <h5 id="_1-grid布局"><a href="#_1-grid布局" class="header-anchor">#</a> 1.grid布局</h5> <p>display 属性</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token property">display</span><span class="token punctuation">:</span>grid 指定一个容器采用网格布局
grid-template-columns 属性定义每一列的列宽
grid-template-rows 属性定义每一行的行高
<span class="token function">repeat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值
auto-fill 关键字表示自动填充
fr 关键字，表示比例关系，如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。
<span class="token function">minmax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值
auto 关键字表示由浏览器自己决定长度
grid-row-gap 属性设置行与行的间隔（行间距）
grid-column-gap属性设置列与列的间隔（列间距）
grid-gap 属性是grid-column-gap和grid-row-gap的合并简写形式
grid-template-areas 属性用于定义区域
grid-auto-flow 属性决定，默认值是row，即<span class="token string">&quot;先行后列&quot;</span>。也可以将它设成column，变成<span class="token string">&quot;先列后行&quot;</span>

justify-items 属性设置单元格内容的水平位置（左中右）
align-items 属性设置单元格内容的垂直位置（上中下）
place-items 属性是align-items属性和justify-items属性的合并简写形式
start：对齐单元格的起始边缘。
end：对齐单元格的结束边缘。
center：单元格内部居中。
stretch：拉伸，占满单元格的整个宽度（默认值）。

justify-content属性是整个内容区域在容器里面的水平位置（左中右）
align-content属性是整个内容区域的垂直位置（上中下）
place-content属性是align-content属性和justify-content属性的合并简写形式
start - 对齐容器的起始边框
end - 对齐容器的结束边框
center - 容器内部居中
stretch - 项目大小没有指定时，拉伸占据整个网格容器
space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍
space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔
space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔

grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。
grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式
</code></pre></div><p>项目属性</p> <div class="language-css extra-class"><pre class="language-css"><code>grid-column-start 属性：左边框所在的垂直网格线
grid-column-end 属性：右边框所在的垂直网格线
grid-row-start 属性：上边框所在的水平网格线
grid-row-end 属性：下边框所在的水平网格线
grid-column 属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。
grid-area 属性指定项目放在哪一个区域

justify-self 属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。
align-self 属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。
start：对齐单元格的起始边缘。
end：对齐单元格的结束边缘。
center：单元格内部居中。
stretch：拉伸，占满单元格的整个宽度（默认值）。
</code></pre></div><p>示例</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">div</span> <span class="token punctuation">{</span>
    <span class="token property">display</span><span class="token punctuation">:</span> grid
<span class="token punctuation">}</span>

<span class="token selector">默认情况下，容器元素都是块级元素，但也可以设成行内元素。
div</span> <span class="token punctuation">{</span>
    <span class="token property">display</span><span class="token punctuation">:</span> inline-grid
<span class="token punctuation">}</span>

<span class="token selector">注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。

.container</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>
  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> 100px 100px 100px<span class="token punctuation">;</span>
  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> 100px 100px 100px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">上面代码指定了一个三行三列的网格，列宽和行高都是100px。除了使用绝对单位，也可以使用百分比：
.container</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>
  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> 33.33% 33.33% 33.33%<span class="token punctuation">;</span>
  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> 33.33% 33.33% 33.33%<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">上面的代码用repeat()改写如下：
.container</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>
  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> <span class="token function">repeat</span><span class="token punctuation">(</span>3<span class="token punctuation">,</span> 33.33%<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> <span class="token function">repeat</span><span class="token punctuation">(</span>3<span class="token punctuation">,</span> 33.33%<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.container</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>
  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> <span class="token function">repeat</span><span class="token punctuation">(</span>auto-fill<span class="token punctuation">,</span> 100px<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">上面代码表示每列宽度100px，然后自动填充，直到容器不能放置更多的列。

.container</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>
  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> 150px 1fr 2fr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
上面代码表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。

<span class="token property">grid-template-columns</span><span class="token punctuation">:</span> 1fr 1fr <span class="token function">minmax</span><span class="token punctuation">(</span>100px<span class="token punctuation">,</span> 1fr<span class="token punctuation">)</span><span class="token punctuation">;</span>
上面代码中，<span class="token function">minmax</span><span class="token punctuation">(</span>100px<span class="token punctuation">,</span> 1fr<span class="token punctuation">)</span>表示列宽不小于100px，不大于1fr

<span class="token property">grid-template-columns</span><span class="token punctuation">:</span> 100px auto 100px<span class="token punctuation">;</span>
上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度。
</code></pre></div><h5 id="_2-瀑布流"><a href="#_2-瀑布流" class="header-anchor">#</a> 2.瀑布流</h5> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c8d4fb3872e4636a3cfa6128a48e128~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">方法一：column实现

- column-count: 定义屏幕分为多少列
- column-gap: 定义列与列之间的距离

body</span><span class="token punctuation">{</span>
    <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">list-style</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">#box</span><span class="token punctuation">{</span>
    <span class="token property">margin</span><span class="token punctuation">:</span> 40px<span class="token punctuation">;</span>
    <span class="token property">column-count</span><span class="token punctuation">:</span> 5<span class="token punctuation">;</span>
    <span class="token property">column-gap</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">#box &gt; li &gt; img</span><span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

优点：

实现简单
图片自动填充不用考虑图片加载状态

缺点：

兼容性差
排列规律永远都是先上下在左右，无法控制
</code></pre></div><div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">方法二：flex布局实现

body</span><span class="token punctuation">{</span>
    <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">list-style</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">#box</span><span class="token punctuation">{</span>
    <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
    <span class="token property">flex-flow</span><span class="token punctuation">:</span> column wrap<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 2000px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">#box &gt; li</span><span class="token punctuation">{</span>
    <span class="token property">margin</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span>100% / 4 - 20px<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">#box &gt; li &gt; img</span><span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

优点：
    实现相对简单
    图片自动填充不用考虑图片加载状态
    顺序在一定程度上可以改变

缺点：
	高度是固定的
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code>方法三：<span class="token constant">JS</span>实现

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Waterfall</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
    * $el：父容器
    * width：每张图片宽度
    * items：所有子元素
    * H：存储每一列的高度
    * flag：虚拟DOM节点集合
    * */</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>$el <span class="token operator">=</span> <span class="token keyword">null</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">4</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>gap <span class="token operator">=</span> <span class="token number">10</span>
        Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token constant">H</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token keyword">null</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'ok'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">.</span>children<span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>flag <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//创建一个空白文档</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">.</span>clientWidth <span class="token operator">/</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token constant">H</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">&quot;&quot;</span>
    <span class="token punctuation">}</span>

    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> <span class="token punctuation">{</span>width<span class="token punctuation">,</span> items<span class="token punctuation">,</span> flag<span class="token punctuation">,</span> <span class="token constant">H</span><span class="token punctuation">,</span> gap<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span>
        items<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            item<span class="token punctuation">.</span>style<span class="token punctuation">.</span>width <span class="token operator">=</span> width <span class="token operator">+</span> <span class="token string">'px'</span>
            item<span class="token punctuation">.</span>style<span class="token punctuation">.</span>position <span class="token operator">=</span> <span class="token string">'absolute'</span>
            <span class="token keyword">let</span> img <span class="token operator">=</span> item<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span>
            <span class="token comment">/* 图片是否加载完成 */</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>img<span class="token punctuation">.</span>complete<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">/* 获取每一列的最小高度 */</span>
                <span class="token keyword">let</span> tag <span class="token operator">=</span> <span class="token constant">H</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token constant">H</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                item<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> tag <span class="token operator">*</span> <span class="token punctuation">(</span>width <span class="token operator">+</span> gap<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'px'</span>
                item<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token constant">H</span><span class="token punctuation">[</span>tag<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'px'</span>
                img<span class="token punctuation">.</span>style<span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token string">'100%'</span>
                img<span class="token punctuation">.</span>style<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token string">'100%'</span>
                <span class="token constant">H</span><span class="token punctuation">[</span>tag<span class="token punctuation">]</span> <span class="token operator">+=</span> img<span class="token punctuation">.</span>height <span class="token operator">*</span> width <span class="token operator">/</span> img<span class="token punctuation">.</span>width <span class="token operator">+</span> gap
                flag<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                img<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'load'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                    <span class="token keyword">let</span> tag <span class="token operator">=</span> <span class="token constant">H</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token constant">H</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    item<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> tag <span class="token operator">*</span> <span class="token punctuation">(</span>width <span class="token operator">+</span> gap<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'px'</span>
                    item<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token constant">H</span><span class="token punctuation">[</span>tag<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'px'</span>
                    img<span class="token punctuation">.</span>style<span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token string">'100%'</span>
                    img<span class="token punctuation">.</span>style<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token string">'100%'</span>
                    <span class="token constant">H</span><span class="token punctuation">[</span>tag<span class="token punctuation">]</span> <span class="token operator">+=</span> img<span class="token punctuation">.</span>height <span class="token operator">*</span> width <span class="token operator">/</span> img<span class="token punctuation">.</span>width <span class="token operator">+</span> gap
                    flag<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
                    <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

实现原理：
    初始化，计算出列宽来，将<span class="token constant">H</span>作为列高存储器。然后计算子元素，清除父容器内容。
    遍历子元素，设置其都为绝对定位，设置其列宽，然后监听其下的图片是否加载完毕。
    如果加载完毕，那么计算应该所在的位置，瀑布流的核心就是哪一列高度最小就在那一列上设置新的图片。当然他的相对高度和间距也要计算出来，同时在当前的<span class="token constant">H</span>上把高度存起来。
    每次图片加载完就更新虚拟节点到父容器中。

优点：
    控制灵活，随意扩展
    也可以无限加载，不用过多考虑兼容性问题
    同时可以添加诸多动画来增强用户体验

缺点：
    实现相对复杂
    图片填充需要考虑图片加载状态
    性能相对纯css实现较差
</code></pre></div><h5 id="_3-css实现垂直居中-3种"><a href="#_3-css实现垂直居中-3种" class="header-anchor">#</a> 3.css实现垂直居中（3种）</h5> <ol><li>flex</li></ol> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li>absolute + translate -50%</li></ol> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.child</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">,</span> -50%<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="3"><li>absolute + 负 margin</li></ol> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.child</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> -150px<span class="token punctuation">;</span>    <span class="token comment">/* 子元素 width 的一半 */</span>
  <span class="token property">margin-top</span><span class="token punctuation">:</span> -100px<span class="token punctuation">;</span>     <span class="token comment">/* 子元素 height 的一半 */</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="4"><li>absolute + margin: auto</li></ol> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.child</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">right</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">bottom</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="5"><li>table 标签</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>table<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>tr<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>td<span class="token operator">&gt;</span>
            Lorem ipsum dolor sit amet<span class="token punctuation">,</span> consectetur adipisicing elit<span class="token punctuation">.</span> Tempora harum voluptates quae velit eveniet<span class="token punctuation">,</span> accusamus<span class="token punctuation">,</span> quas ratione placeat<span class="token operator">!</span> Nisi perferendis facere<span class="token punctuation">,</span> error sed possimus molestias et<span class="token punctuation">.</span> Quas accusantium<span class="token punctuation">,</span> maiores aliquid<span class="token operator">?</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>td<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>tr<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>table<span class="token operator">&gt;</span>

</code></pre></div><ol start="6"><li>div 模仿 table</li></ol> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.child</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>
  <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="7"><li>高度为 100% 的伪元素 + display: inline-block</li></ol> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.parent:before,
.parent:after</span> <span class="token punctuation">{</span>
  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>            <span class="token comment">/* 前后伪元素高度 100% */</span>
  <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>  <span class="token comment">/* 伪元素垂直居中 */</span>
<span class="token punctuation">}</span>

<span class="token selector">.child</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>
  <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>  <span class="token comment">/* 子元素在 100% 高度中垂直居中 */</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="js"><a href="#js" class="header-anchor">#</a> JS</h4> <h5 id="_1-分片上传底层原理"><a href="#_1-分片上传底层原理" class="header-anchor">#</a> 1.分片上传底层原理</h5> <p><strong>Blob</strong>对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成 ReadableStream 来用于数据操作。</p> <p>File接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p> <p><strong>Blob.slice()</strong></p> <p>返回一个新的 Blob 对象，包含了源 Blob 对象中指定范围内的数据。和数组的slice方法类似，截取数组的内容，大文件切片就是基于此方法来切分。</p> <h5 id="_2-防抖节流"><a href="#_2-防抖节流" class="header-anchor">#</a> 2.防抖节流</h5> <h5 id="_3-原型和原型链"><a href="#_3-原型和原型链" class="header-anchor">#</a> 3.原型和原型链</h5> <h5 id="_4-事件冒泡和委托原理和应用"><a href="#_4-事件冒泡和委托原理和应用" class="header-anchor">#</a> 4.事件冒泡和委托原理和应用</h5> <ol><li>事件冒泡</li></ol> <p>​	给子盒子和父盒子添加点击事件，点击子盒子绑定的事件，同时也会触发父盒子绑定的事件。其实这种现象就叫做JavaScript的事件冒泡。之所以会出现这种情况，是因为js的事件传播过程是目标元素触发事件后，该事件会逐级传播给祖先元素，直到document为止，有的浏览器可能到window。</p> <ol start="2"><li>事件捕获</li></ol> <p>​	事件捕获和事件冒泡相反，它从外部的祖先元素开始，传播到事件触发的元素。</p> <ol start="3"><li>事件委托</li></ol> <p>​	在JavaScript中，绑定到元素上的事件数量将直接关系到页面的整体运行性能，因为需要不断的操作dom,那么引起浏览器重绘和回流的可能也就越多，这就需要我们尽量少的操作dom。本来需要绑定多个事件的情况，现在只需要绑定一个事件就可以实现原有的效果，这样做一方面可以减少内存被占用的空间，另一方面对应用的整体性能提升也有积极的作用 。如果要用事件委托，就会将所有的操作放到js程序里面，只对它的父级(如果只有一个父级)这一个对象进行操作，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能。</p> <p><strong>事件委托，也叫事件代理，主要是利用事件冒泡原理，从目标节点开始，逐渐向上传播事件，最终将事件委托给它的父级节点。</strong></p> <h5 id="_5-数组深拷贝的实现方法"><a href="#_5-数组深拷贝的实现方法" class="header-anchor">#</a> 5.数组深拷贝的实现方法</h5> <h5 id="_6-var和let的区别"><a href="#_6-var和let的区别" class="header-anchor">#</a> 6.var和let的区别</h5> <p><code>var</code>关键字声明的变量，都会被提升到该作用域的最顶部；</p> <p><code>let</code>声明的变量只在当前作用域中有效</p> <p><code>const</code>声明指的是常量，常量就是一旦定义完就不能修改的值</p> <h5 id="_7-原生ajax的过程实现"><a href="#_7-原生ajax的过程实现" class="header-anchor">#</a> 7.原生ajax的过程实现</h5> <ol><li>创建 XMLHttpRequest 对象  var xhr = new XMLHttpRequest()</li> <li>调用open方法，设置请求方式和请求路径url  xhr.open('get', url)</li> <li>调用send方法，发送请求 xhr.send()</li> <li>准备一个函数，用于接受服务器响应的结果</li></ol> <h5 id="_8-eventloop事件轮循"><a href="#_8-eventloop事件轮循" class="header-anchor">#</a> 8.eventloop事件轮循</h5> <p>所有异步任务在执行过程，都是从异步任务队列中将回调函数拿到了任务栈中来执行，此时执行完任务栈里面的代码后，还是会继续按照之前的方式，先从微任务中拿，再从宏任务拿</p> <h5 id="_9-一个字符串-获取每个数字出现的次数"><a href="#_9-一个字符串-获取每个数字出现的次数" class="header-anchor">#</a> 9.一个字符串，获取每个数字出现的次数</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> str<span class="token operator">=</span><span class="token string">&quot;helloworldilikeyou&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">//创建一个对象用于保存每个字符以及他的次数</span>
			 <span class="token comment">//把str中的每个字符当对象的属性名；</span>
			 <span class="token comment">//由于对象的属性名是唯一的，所以就不会存在重复的字符；</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>str<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> key<span class="token operator">=</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  		 <span class="token comment">//遍历字符串，key的值就是str的每个字符</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">==</span><span class="token keyword">undefined</span><span class="token punctuation">)</span>  <span class="token comment">//判断如果新对象中，有没有我们遍历的字符，如果没有，</span>
       obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>           <span class="token comment">//就在对象中添加一个属性和值， 属性名就是遍历的字符串</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                   <span class="token comment">//反之-就是对象中已经有一个这样的字符了，当然他这个时候值就是1</span>
    	obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>          <span class="token comment">//第二次遍历到他的时候就把他原来的值加1，再赋值给他</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  下图就是获取到的每个字符出现的次数
</code></pre></div><h5 id="_10-一个字符串-获取连续出现的字符串"><a href="#_10-一个字符串-获取连续出现的字符串" class="header-anchor">#</a> 10.一个字符串，获取连续出现的字符串</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//首先写一个函数，传入一个字符串</span>
<span class="token keyword">function</span> <span class="token function">getMaxCharacters</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">//match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。</span>
    <span class="token keyword">var</span> arr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\w)\1+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">)</span>
    <span class="token keyword">var</span> max <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length
    arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=&gt;</span> max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> v<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> maxArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=&gt;</span> v<span class="token punctuation">.</span>length <span class="token operator">===</span> max<span class="token punctuation">)</span>
    maxArr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        map<span class="token punctuation">[</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">.</span>length
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> map
<span class="token punctuation">}</span>

<span class="token function">getMaxCharacters</span><span class="token punctuation">(</span><span class="token string">'abcaakjbb'</span><span class="token punctuation">)</span>  <span class="token comment">// { a: 2, b: 2 }</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">getMaxCharacters</span><span class="token punctuation">(</span><span class="token string">'abcaakjbb'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h5 id="_11-数据的基本类型"><a href="#_11-数据的基本类型" class="header-anchor">#</a> 11.数据的基本类型</h5> <h5 id="_12-判断数据类型的方法"><a href="#_12-判断数据类型的方法" class="header-anchor">#</a> 12.判断数据类型的方法</h5> <h5 id="_13-object-defineproperty和proxy的区别"><a href="#_13-object-defineproperty和proxy的区别" class="header-anchor">#</a> 13.Object.defineProperty和proxy的区别</h5> <h5 id="_14-async-await的用法、原理-await返回的是什么"><a href="#_14-async-await的用法、原理-await返回的是什么" class="header-anchor">#</a> 14.async await的用法、原理，await返回的是什么</h5> <ul><li>await只能在async函数中使用，不然会报错</li> <li>async函数返回的是一个Promise对象，有无值看有无return值</li> <li>await后面最好是接Promise，虽然接其他值也能达到排队效果</li> <li>async/await作用是<strong>用同步方式，执行异步操作</strong></li></ul> <h5 id="_15-promise的用法及原理"><a href="#_15-promise的用法及原理" class="header-anchor">#</a> 15.promise的用法及原理</h5> <p>Promise是一个构造函数，必须接收一个<strong>函数</strong>作为参数，我们称该函数为executor（执行器），executor又包含了两个<strong>函数</strong>作为参数，分别是resolve和reject，当异步操作成功后马上执行resolve，异步操作失败后，会马上执行reject</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyPromise</span><span class="token punctuation">{</span>
     <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> executor <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'MyPromise必须接收一个函数作为参数'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 执行传进来的函数executor</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">executor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

promise中有<span class="token keyword">throw</span>的话，就相当于执行了reject。这就要使用<span class="token keyword">try</span> catch了
为什么要绑定<span class="token keyword">this</span>呢？这是为了resolve和reject的<span class="token keyword">this</span>指向永远指向当前的MyPromise实例，防止随着函数执行环境的改变而改变
</code></pre></div><p>Promise有三种状态，分别是Pending（等待中），Fulfilled（已成功），Rejected（已失败）。</p> <p>状态只能由<code>Pending</code>变成<code>Fulfilled</code>， 或由<code>Pending</code>变成<code>Rejected</code>，且状态确定后不会再发生变化（不能再次修改）。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 定义三种状态常量</span>
<span class="token keyword">const</span> <span class="token constant">PENDING</span> <span class="token operator">=</span> <span class="token string">'pending'</span>
<span class="token keyword">const</span> <span class="token constant">FULFILLED</span> <span class="token operator">=</span> <span class="token string">'fulfilled'</span>
<span class="token keyword">const</span> <span class="token constant">REJECTED</span> <span class="token operator">=</span> <span class="token string">'reject'</span>

<span class="token keyword">class</span> <span class="token class-name">MyPromise</span><span class="token punctuation">{</span>
  status <span class="token operator">=</span> <span class="token constant">PENDING</span>  <span class="token comment">// 设置初始状态</span>
  value <span class="token operator">=</span> <span class="token keyword">undefined</span>  <span class="token comment">// 设置初始值</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> executor <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'MyPromise必须接收一个函数作为参数'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 执行executor</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">executor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">FULFILLED</span>  <span class="token comment">// 修改状态</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> val  <span class="token comment">// 修改值</span>
  <span class="token punctuation">}</span>
  <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token constant">REJECT</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">REJECT</span>   <span class="token comment">// 修改状态</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> err  <span class="token comment">// 修改值</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Promise核心：then方法</p> <ul><li>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是<strong>为 Promise 实例添加状态改变时的回调函数</strong>。</li> <li>then方法<strong>接收两个可选参数</strong><code>onFulfilled</code> 和<code>onRejected</code>，参数必须是函数</li> <li><code>then</code>方法<strong>返回的是一个新的<code>Promise</code>实例</strong>（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</li> <li><strong><code>Promise</code> 实例化时传入的函数会立即执行，<code>then(...)</code> 中的回调需要异步延迟调用。</strong></li></ul> <h5 id="_16-函数的柯里化及作用"><a href="#_16-函数的柯里化及作用" class="header-anchor">#</a> 16.函数的柯里化及作用</h5> <p>主要有3个作用： <strong>参数复用</strong>、<strong>提前返回</strong>和 <strong>延迟执行</strong></p> <p>我们来简单的解释一下: 参数复用：拿上面 <code>f</code>这个函数举例，只要传入一个参数 <code>z</code>，执行，计算结果就是 <code>1 + 2 + z</code> 的结果，1 和 2 这两个参数就直接可以复用了。</p> <p>提前返回 和 延迟执行 也很好理解，因为每次调用函数时，它只接受一部分参数，并返回一个函数（提前返回），直到(延迟执行)传递所有参数为止。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * 将函数柯里化
 * @param fn    待柯里化的原函数
 * @param len   所需的参数个数，默认为原函数的形参个数
 */</span>
<span class="token keyword">function</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>len <span class="token operator">=</span> fn<span class="token punctuation">.</span>length</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">_curry</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>fn<span class="token punctuation">,</span>len<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 中转函数
 * @param fn    待柯里化的原函数
 * @param len   所需的参数个数
 * @param args  已接收的参数列表
 */</span>
<span class="token keyword">function</span> <span class="token function">_curry</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>len<span class="token punctuation">,</span><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> _args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>args<span class="token punctuation">,</span><span class="token operator">...</span>params<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>_args<span class="token punctuation">.</span>length <span class="token operator">&gt;=</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>_args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">_curry</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>fn<span class="token punctuation">,</span>len<span class="token punctuation">,</span><span class="token operator">...</span>_args<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="_17-函数的执行流程"><a href="#_17-函数的执行流程" class="header-anchor">#</a> 17.函数的执行流程</h5> <ol><li>为函数创建一个执行环境</li> <li>复制函数的 [[scopes]] 属性中的对象构建起执行环境的作用链域</li> <li>创建函数活动对象并推入执行环境作用链域的前端</li> <li>执行代码</li> <li>销毁执行环境和活动对象（闭包情况下活动对象仍被引用没被销毁）</li></ol> <h5 id="_18-进程和线程的区别"><a href="#_18-进程和线程的区别" class="header-anchor">#</a> 18.进程和线程的区别</h5> <p>做个简单的比喻：进程=火车，线程=车厢</p> <ul><li>线程在进程下行进（单纯的车厢无法运行）</li> <li>一个进程可以包含多个线程（一辆火车可以有多个车厢）</li> <li>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）</li> <li>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）</li> <li>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</li> <li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）</li> <li>进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）</li> <li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－&quot;互斥锁&quot;</li> <li>进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”</li></ul> <h5 id="_22-try-catch-中可以捕捉错误的类型"><a href="#_22-try-catch-中可以捕捉错误的类型" class="header-anchor">#</a> 22.try catch 中可以捕捉错误的类型</h5> <p>建议将<code>try</code>与<code>catch</code>块一起使用，它可以优雅地处理<code>try</code>块抛出的错误。</p> <ol><li><code>try..catch</code> 无法捕获无效的 JS 代码</li> <li><code>try..catch</code>无法捕获在异步代码中引发的异常</li> <li>嵌套 <code>try..catch</code></li> <li>在 <code>async await</code> 中 使用<code>try..catch</code> 比较容易</li></ol> <h5 id="_23-for-of-和for-in的区别"><a href="#_23-for-of-和for-in的区别" class="header-anchor">#</a> 23.for of 和for in的区别</h5> <p>简单来说就是它们两者都可以用于遍历，不过<code>for in</code>遍历的是数组的索引（<code>index</code>），而<code>for of</code>遍历的是数组元素值（<code>value</code>）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// for in</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">a</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">b</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">c</span><span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">}</span>
    
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// a b c</span>

<span class="token comment">//for of</span>
<span class="token keyword">const</span> array1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span>
 
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> val <span class="token keyword">of</span> array1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// a b c</span>
</code></pre></div><h5 id="_24-new一个实例的执行流程"><a href="#_24-new一个实例的执行流程" class="header-anchor">#</a> 24.new一个实例的执行流程</h5> <p>(1) 创建一个新对象；
(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） ；
(3) 执行构造函数中的代码（为这个新对象添加属性） ；
(4) 返回新对象。</p> <h5 id="_25-反转一个链表"><a href="#_25-反转一个链表" class="header-anchor">#</a> 25.反转一个链表</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">reverseList</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> curr <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>curr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> next <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        curr<span class="token punctuation">.</span>next <span class="token operator">=</span> prev<span class="token punctuation">;</span>
        prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>
        curr <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> prev<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="_26-http为什么是三次握手-四次挥手"><a href="#_26-http为什么是三次握手-四次挥手" class="header-anchor">#</a> 26.http为什么是三次握手？四次挥手？</h5> <p>第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p> <p>第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p> <p>第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常</p> <p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中<strong>ACK报文是用来应答的，SYN报文是用来同步的</strong>。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，&quot;你发的FIN报文我收到了&quot;。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p> <h5 id="_27-https是怎么进行加密的"><a href="#_27-https是怎么进行加密的" class="header-anchor">#</a> 27.https是怎么进行加密的？</h5> <p>HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法</p> <ul><li>散列函数 散列函数验证信息的完整性</li> <li>对称加密 对称加密算法采用协商的密钥对数据加密</li> <li>非对称加密 非对称加密实现身份认证和密钥协商</li></ul> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f94b302f31154dc385821ec2c31c1e5b~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png"></p> <h5 id="_28-像素px和物理像素的关系"><a href="#_28-像素px和物理像素的关系" class="header-anchor">#</a> 28.像素px和物理像素的关系</h5> <ul><li><p>物理像素是硬件条件所决定的</p></li> <li><p>逻辑分辨率可以任意设置，大小不受限于物理分辨率</p></li> <li><p>css 样式中的 px 为逻辑像素</p></li> <li><p>单位面积内逻辑像素越多，显示的内容越多</p></li> <li><p>逻辑像素无法和物理像素完全对应的情况下，会可能存在显示问题</p></li> <li><p>与物理像素完全匹配的设计展示最清新，过低太模糊、过高被压缩</p></li></ul> <h5 id="_29-pc端和h5怎么兼容-除了响应式"><a href="#_29-pc端和h5怎么兼容-除了响应式" class="header-anchor">#</a> 29.pc端和H5怎么兼容？除了响应式</h5> <h5 id="_30-es6中箭头函数"><a href="#_30-es6中箭头函数" class="header-anchor">#</a> 30.ES6中箭头函数</h5> <ol><li>箭头函数的this永远指向其父作用域，任何方法都改变不了，包括call，apply，bind。普通函数的this指向调用它的那个对象。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'jike'</span><span class="token punctuation">,</span>
    <span class="token function-variable function">init</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//为body添加一个点击事件，看看这个点击后的this属性有什么不同</span>
        document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//?? this在浏览器默认是调用时的对象,可变的？                  </span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
person<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

上例中，init是<span class="token keyword">function</span>，以person<span class="token punctuation">.</span>init调用，其内部<span class="token keyword">this</span>就是person本身，而onclick回调是箭头函数，
其内部的<span class="token keyword">this</span>，就是父作用域的<span class="token keyword">this</span>，就是person，能得到name。

<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'jike'</span><span class="token punctuation">,</span>
    <span class="token function-variable function">init</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token comment">//为body添加一个点击事件，看看这个点击后的this属性有什么不同</span>
        document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//?? this在浏览器默认是调用时的对象,可变的？                  </span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
person<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

上例中，init为箭头函数，其内部的<span class="token keyword">this</span>为全局window，onclick的<span class="token keyword">this</span>也就是init函数的<span class="token keyword">this</span>，也是window，
得到的<span class="token keyword">this</span><span class="token punctuation">.</span>name就为<span class="token keyword">undefined</span>。
</code></pre></div><ol start="2"><li>箭头函数不能作为构造函数，不能使用new</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//构造函数如下：</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">p</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> p<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//如果用箭头函数作为构造函数，则如下</span>
<span class="token keyword">var</span> <span class="token function-variable function">Person</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">p</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> p<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

由于<span class="token keyword">this</span>必须是对象实例，而箭头函数是没有实例的，此处的<span class="token keyword">this</span>指向别处，不能产生person实例，自相矛盾。
</code></pre></div><ol start="3"><li>箭头函数没有arguments，caller，callee</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>箭头函数本身没有arguments，如果箭头函数在一个<span class="token keyword">function</span>内部，它会将外部函数的arguments拿过来使用。
箭头函数中要想接收不定参数，应该使用rest参数<span class="token operator">...</span>解决。

<span class="token keyword">let</span> <span class="token function-variable function">B</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">b</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token constant">B</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">92</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Uncaught ReferenceError: arguments is not defined</span>

<span class="token keyword">let</span> <span class="token function-variable function">C</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>c</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token constant">C</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">82</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token number">11323</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// [3, 82, 32, 11323]</span>
</code></pre></div><ol start="4"><li>箭头函数通过call和apply调用，不会改变this指向，只会传入参数</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
    <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> n <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">c</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> n <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span>
        <span class="token keyword">let</span> m <span class="token operator">=</span> <span class="token punctuation">{</span>
            <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">20</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">.</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 11</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">.</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 11</span>
</code></pre></div><ol start="5"><li>箭头函数没有原型属性</li> <li>箭头函数不能作为Generator函数，不能使用yield关键字</li> <li>箭头函数返回对象时，要加一个小括号</li></ol> <h5 id="_31-js-实现两个大数相加"><a href="#_31-js-实现两个大数相加" class="header-anchor">#</a> 31.JS 实现两个大数相加？</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">&quot;9007199254740991&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token string">&quot;1234567899999999999&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a <span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token comment">//取两个数字的最大长度</span>
   <span class="token keyword">let</span> maxLength <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>length<span class="token punctuation">,</span> b<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment">//用0去补齐长度</span>
   a <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">padStart</span><span class="token punctuation">(</span>maxLength <span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//&quot;0009007199254740991&quot;</span>
   b <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">padStart</span><span class="token punctuation">(</span>maxLength <span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//&quot;1234567899999999999&quot;</span>
   <span class="token comment">//定义加法过程中需要用到的变量</span>
   <span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">//&quot;进位&quot;</span>
   <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span>maxLength<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span> i<span class="token operator">&gt;=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      t <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> f<span class="token punctuation">;</span>
      f <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>t<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      sum <span class="token operator">=</span> t<span class="token operator">%</span><span class="token number">10</span> <span class="token operator">+</span> sum<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">if</span><span class="token punctuation">(</span>f <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      sum <span class="token operator">=</span> <span class="token string">&quot;1&quot;</span> <span class="token operator">+</span> sum<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="_32-es6中的set和map"><a href="#_32-es6中的set和map" class="header-anchor">#</a> 32.ES6中的Set和Map</h5> <ol><li>Map</li></ol> <p>​	<code>Map</code>对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。构造函数<code>Map</code>可以接受一个数组作为参数。</p> <p>​	<strong>Map和Object的区别</strong></p> <ul><li><p>一个<code>Object</code> 的键只能是字符串或者 <code>Symbols</code>，但一个<code>Map</code> 的键可以是任意值。</p></li> <li><p><code>Map</code>中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。</p></li> <li><p><code>Map</code>的键值对个数可以从 size 属性获取，而 <code>Object</code> 的键值对个数只能手动计算。</p></li> <li><p><code>Object</code> 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</p></li></ul> <p>​	<strong>Map对象的属性</strong></p> <ul><li>size：返回Map对象中所包含的键值对个数</li></ul> <p>​	<strong>Map对象的方法</strong></p> <ul><li><code>set(key, val)</code>: 向Map中添加新元素</li> <li><code>get(key)</code>: 通过键值查找特定的数值并返回</li> <li><code>has(key)</code>: 判断Map对象中是否有Key所对应的值，有返回true,否则返回false</li> <li><code>delete(key)</code>: 通过键值从Map中移除对应的数据</li> <li><code>clear()</code>: 将这个Map中的所有元素删除</li></ul> <p>​	<strong>遍历方法</strong></p> <ul><li><code>keys()</code>：返回键名的遍历器</li> <li><code>values()</code>：返回键值的遍历器</li> <li><code>entries()</code>：返回键值对的遍历器</li> <li><code>forEach()</code>：使用回调函数遍历每个成员</li></ul> <div class="language-JS extra-class"><pre class="language-js"><code><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">,</span>  <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">of</span> map<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// &quot;a&quot;</span>
<span class="token comment">// &quot;b&quot;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> value <span class="token keyword">of</span> map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 1</span>
<span class="token comment">// 2</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> map<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// [&quot;a&quot;, 1]</span>
<span class="token comment">// [&quot;b&quot;, 2]</span>

<span class="token comment">// 或者</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> map<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// &quot;a&quot; 1</span>
<span class="token comment">// &quot;b&quot; 2</span>

<span class="token comment">// for...of...遍历map等同于使用map.entries()</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// &quot;a&quot; 1</span>
<span class="token comment">// &quot;b&quot; 2</span>
</code></pre></div><p>​	<strong>map与其他数据结构的互相转换</strong></p> <ul><li>map转换为数组（使用扩展运算符）</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string-property property">'a'</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">111</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'b'</span><span class="token operator">:</span> <span class="token number">222</span><span class="token punctuation">]</span><span class="token punctuation">]</span>

<span class="token keyword">const</span> myMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>

<span class="token punctuation">[</span><span class="token operator">...</span>myMap<span class="token punctuation">]</span> <span class="token comment">// map转数组。 [[{'a': 1}, 111], ['b': 222]]</span>
</code></pre></div><ul><li><code>Map</code>与对象的互换</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">111</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">222</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span>value<span class="token punctuation">]</span> <span class="token keyword">of</span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token comment">// {a:111, b: 222}</span>
</code></pre></div><ul><li><code>JSON</code>字符串要转换成<code>Map</code>可以先利用JSON.parse()转换成数组或者对象，然后再转换即可。</li></ul> <ol start="2"><li>Set</li></ol> <p>​	<code>Set</code>对象允许你存储任何类型的值，无论是原始值或者是对象引用。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p> <p>​	<code>Set</code> 本身是一个构造函数，用来生成<code>Set</code> 数据结构。<code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p> <p>​	<strong>Set中的特殊值</strong></p> <p>​	<code>Set</code> 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：</p> <ul><li>+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复</li> <li>undefined 与 undefined 是恒等的，所以不重复</li> <li>NaN 与 NaN 是不恒等的，但是在 Set 中认为NaN与NaN相等，所有只能存在一个，不重复。</li></ul> <p>​	<strong>Set实例对象的属性</strong></p> <ul><li>size：返回Set实例的成员总数。</li></ul> <p>​	<strong>Set实例对象的方法</strong></p> <ul><li><code>add(value)</code>：添加某个值，返回 Set 结构本身(可以链式调用)。</li> <li><code>delete(value)</code>：删除某个值，删除成功返回<code>true</code>，否则返回<code>false</code>。</li> <li><code>has(value)</code>：返回一个布尔值，表示该值是否为Set的成员。</li> <li><code>clear()</code>：清除所有成员，没有返回值。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> mySet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mySet<span class="token punctuation">)</span>  <span class="token comment">// {'a', 'b', 1, 2}</span>
myset<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string-property property">'a'</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mySet<span class="token punctuation">)</span> <span class="token comment">// {'a', 'b', 1, 2, 'c', {a: 1}}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mySet<span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token comment">// 6</span>

mySet<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div><p>​	<strong>遍历方法</strong></p> <ul><li><code>keys()</code>：返回键名的遍历器。</li> <li><code>values()</code>：返回键值的遍历器。</li> <li><code>entries()</code>：返回键值对的遍历器。</li> <li><code>forEach()</code>：使用回调函数遍历每个成员。</li></ul> <p>​	由于<code>Set</code>结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> set<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// a</span>
<span class="token comment">// b</span>
<span class="token comment">// c</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> set<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// a</span>
<span class="token comment">// b</span>
<span class="token comment">// c</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> set<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// [&quot;a&quot;, &quot;a&quot;]</span>
<span class="token comment">// [&quot;b&quot;, &quot;b&quot;]</span>
<span class="token comment">// [&quot;c&quot;, &quot;c&quot;]</span>

<span class="token comment">// 直接遍历set实例，等同于遍历set实例的values方法</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">of</span> set<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// a</span>
<span class="token comment">// b</span>
<span class="token comment">// c</span>

set<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">' : '</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// a: a</span>
<span class="token comment">// b: b</span>
<span class="token comment">// c: c</span>
</code></pre></div><p>​	<strong>Set 对象作用</strong></p> <ul><li>数组去重(利用扩展运算符)</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> mySet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token operator">...</span>mySet<span class="token punctuation">]</span> <span class="token comment">// [1, 2, 3, 4]</span>
</code></pre></div><ul><li>合并两个set对象</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> union <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>a<span class="token punctuation">,</span> <span class="token operator">...</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// {1, 2, 3, 4}</span>
</code></pre></div><ul><li>交集</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> intersect <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>a<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=&gt;</span> b<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// {2, 3} 利用数组的filter方法</span>
</code></pre></div><ul><li>差集</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> difference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>a<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span>b<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//  {1} </span>
</code></pre></div><h5 id="_33-给你一个字符串数组-words-只返回可以使用在-美式键盘-同一行的字母打印出来的单词。键盘如下图所示。"><a href="#_33-给你一个字符串数组-words-只返回可以使用在-美式键盘-同一行的字母打印出来的单词。键盘如下图所示。" class="header-anchor">#</a> 33. 给你一个字符串数组 words ，只返回可以使用在 美式键盘 同一行的字母打印出来的单词。键盘如下图所示。</h5> <p>美式键盘 中：</p> <p>第一行由字符 &quot;qwertyuiop&quot; 组成。
第二行由字符 &quot;asdfghjkl&quot; 组成。
第三行由字符 &quot;zxcvbnm&quot; 组成。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">findWords</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">words</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> rowIdx <span class="token operator">=</span> <span class="token string">&quot;12210111011122000010020202&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> word <span class="token keyword">of</span> words<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> isValid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> idx <span class="token operator">=</span> rowIdx<span class="token punctuation">[</span>word<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> word<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>rowIdx<span class="token punctuation">[</span>word<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">!==</span> idx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                isValid <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>isValid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            list<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

我们为每一个英文字母标记其对应键盘上的行号，然后检测字符串中所有字符对应的行号是否相同。

我们可以预处理计算出每个字符对应的行号。

遍历字符串时，统一将大写字母转化为小写字母方便计算。
</code></pre></div><h5 id="_34-axios中进行重定向"><a href="#_34-axios中进行重定向" class="header-anchor">#</a> 34. axios中进行重定向</h5> <p>浏览器发送的<a href="https://so.csdn.net/so/search?q=ajax&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">ajax<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>请求，服务端返回了302状态码，浏览器会自行跳转，我们无法通过 js 库(jquery, axios) 直接得到并自定义处理流程，只能等到浏览器重定向之后的url获取相应信</p> <p>息。</p> <p>axios 发送ajax --&gt;</p> <p>server 返回302和location --&gt;</p> <p>浏览器请求新的url --&gt;</p> <p>服务端返回200 --&gt;</p> <p>axios 获取结果</p> <p>那么怎么解决呢？需要服务端配合解决</p> <p>Brower (ajax and not auth) --&gt;</p> <p>server判断是ajax请求，未登陆，返回 401状态码 --&gt;</p> <p>浏览器 axios 拦截401，并且通过js 跳转到 /login</p> <h5 id="_35-common-js和es6中模块的区别"><a href="#_35-common-js和es6中模块的区别" class="header-anchor">#</a> 35.common.js和es6中模块的区别？</h5> <ul><li><p>ES6模块特点</p> <ol><li>设计思想是尽量静态化（编译时加载），使得编译时就能确定模块的依赖关系、输入输出变量。</li> <li>由于 ES6 模块是编译时加载，使得静态分析成为可能。</li> <li>ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。</li> <li>ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。</li> <li>export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</li> <li>import命令输入的变量都是只读的，因为它的本质是输入接口</li> <li>import命令具有提升效果，会提升到整个模块的头部，首先执行。</li> <li>import语句会执行所加载的模块。</li></ol></li> <li><p>CommonJS</p> <ol><li>运行时确定模块的依赖关系、输入输出变量</li> <li>CommonJS 模块输出的是值的缓存，不存在动态更新</li> <li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li> <li>就是this关键字。ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块，这是两者的一个重大差异。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">{</span>m1<span class="token punctuation">,</span>m2<span class="token punctuation">,</span>m3<span class="token punctuation">}</span>  <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'modules'</span><span class="token punctuation">)</span>
            <span class="token operator">&lt;=</span><span class="token operator">&gt;</span>
<span class="token keyword">let</span> m <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'modules'</span><span class="token punctuation">)</span> <span class="token comment">//整体加载modules模块</span>
<span class="token keyword">let</span> m1 <span class="token operator">=</span> m<span class="token punctuation">.</span>m1
<span class="token keyword">let</span> m2 <span class="token operator">=</span> m<span class="token punctuation">.</span>m2
<span class="token keyword">let</span> m3 <span class="token operator">=</span> m<span class="token punctuation">.</span>m3
复制代码
</code></pre></div></li> <li><p>AMD</p> <blockquote><p>实现AMD的工具库 require.js</p></blockquote> <ol><li>运行时确定模块的依赖关系、输入输出变量</li> <li>全局定义define函数</li> <li>全局定义require函数</li> <li>依赖的JS会自动异步加载</li></ol></li> <li><p>比较</p> <ol><li>因为require是运行时加载模块，import命令无法取代require的动态加载功能。</li> <li>import()类似于 Node的require方法，区别主要是前者是异步加载，后者是同步加载。</li></ol></li> <li><p>浏览器异步加载脚本的方法</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt;
&lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt;
复制代码
</code></pre></div><blockquote><p>渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p></blockquote></li> <li><p>defer和async的区别</p> <blockquote><p>defer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。</p></blockquote></li></ul> <h5 id="_36-tree-shaking是如何工作的"><a href="#_36-tree-shaking是如何工作的" class="header-anchor">#</a> 36.tree-shaking是如何工作的？</h5> <p>Webpack 中，Tree-shaking 的实现一是先<strong>标记</strong>出模块导出值中哪些没有被用过，二是使用 Terser 删掉这些没被用到的导出语句。标记过程大致可划分为三个步骤：</p> <ul><li>Make 阶段，收集模块导出变量并记录到模块依赖关系图 ModuleGraph 变量中</li> <li>Seal 阶段，遍历 ModuleGraph 标记模块导出变量有没有被使用</li> <li>生成产物时，若变量没有被其它模块使用则删除对应的导出语句</li></ul> <blockquote><p>标记功能需要配置 <code>optimization.usedExports = true</code> 开启</p></blockquote> <p>也就是说，标记的效果就是删除没有被其它模块使用的导出语句</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64044294f29e449e9c6016e724a93fdd~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p> <p>示例中，<code>bar.js</code> 模块(左二)导出了两个变量：<code>bar</code> 与 <code>foo</code>，其中 <code>foo</code> 没有被其它模块用到，所以经过标记后，构建产物(右一)中 <code>foo</code> 变量对应的导出语句就被删除了。作为对比，如果没有启动标记功能(<code>optimization.usedExports = false</code> 时)，则变量无论有没有被用到都会保留导出语句，如上图右二的产物代码所示。</p> <p>注意，这个时候 <code>foo</code> 变量对应的代码 <code>const foo='foo'</code> 都还保留完整，这是因为标记功能只会影响到模块的导出语句，真正执行“<strong>Shaking</strong>”操作的是 Terser 插件。例如在上例中 <code>foo</code> 变量经过标记后，已经变成一段 Dead Code —— 不可能被执行到的代码，这个时候只需要用 Terser 提供的 DCE 功能就可以删除这一段定义语句，以此实现完整的 Tree Shaking 效果。</p> <p>ES6 module 特点：</p> <ul><li>只能作为模块顶层的语句出现</li> <li>import 的模块名只能是字符串常量</li> <li>import binding 是 immutable的</li></ul> <p>ES6模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是tree-shaking的基础。</p> <p>所谓静态分析就是不执行代码，从字面量上对代码进行分析，ES6之前的模块化，比如我们可以动态require一个模块，只有执行后才知道引用的什么模块，这个就不能通过静态分析去做优化。</p> <p>这是 ES6 modules 在设计时的一个重要考量，也是为什么没有直接采用 CommonJS，正是基于这个基础上，才使得 tree-shaking 成为可能，这也是为什么 rollup 和 webpack 2 都要用 ES6 module syntax 才能 tree-shaking。</p> <h4 id="vue"><a href="#vue" class="header-anchor">#</a> VUE</h4> <h5 id="_1-spa首屏加载慢怎么解决"><a href="#_1-spa首屏加载慢怎么解决" class="header-anchor">#</a> 1.SPA首屏加载慢怎么解决</h5> <ol><li><p>减少入口文件体积：常用的手段是路由懒加载，把不同的路由对应的组件分割成不同的代码块，待路由被请求的时候单独打包路由，使入口文件变小。</p></li> <li><p>静态资源本地缓存：后端返回资源问题：采用HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头。采用Service Worker离线缓存。前端合理利用localStorage。</p></li> <li><p>UI框架在引用时按需加载，开发过程中可能不止用到一个组件库，全局引入很不推荐！</p></li> <li><p>避免组件重复打包：在webpack的config文件中，修改CommonsChunkPlugin的配置，设置minChunks为2表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件</p></li> <li><p>压缩图片资源，应用自身常用图标，logo等可以放在assets,其余图片可以放在静态托管目录public里面。</p></li> <li><p>使用SSR（服务端渲染），即组件和页面通过服务器生成html字符串，再发送到浏览器。vue可以使用Nuxt.js实现服务端渲染。</p></li></ol> <h5 id="_2-key的作用及什么时候用index-什么是用id"><a href="#_2-key的作用及什么时候用index-什么是用id" class="header-anchor">#</a> 2.key的作用及什么时候用index,什么是用id</h5> <h5 id="_3-data为什么是函数"><a href="#_3-data为什么是函数" class="header-anchor">#</a> 3.data为什么是函数</h5> <ul><li>因为组件是用来复用的，且 JS 里对象是引用关系，</li> <li>如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响</li> <li>如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响</li> <li>而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题</li></ul> <h5 id="_4-diff算法"><a href="#_4-diff算法" class="header-anchor">#</a> 4.diff算法</h5> <p>在js中,渲染真实<code>DOM</code>的开销是非常大的, 比如我们修改了某个数据,如果直接渲染到真实<code>DOM</code>, 会引起整个<code>dom</code>树的重绘和重排。那么有没有可能实现只更新我们修改的那一小块dom而不要更新整个<code>dom</code>呢？此时我们就需要先根据真实<code>dom</code>生成虚拟<code>dom</code>， 当虚拟<code>dom</code>某个节点的数据改变后会生成有一个新的<code>Vnode</code>, 然后新的<code>Vnode</code>和旧的<code>Vnode</code>作比较，发现有不一样的地方就直接修改在真实DOM上，然后使旧的<code>Vnode</code>的值为新的<code>Vnode</code>。</p> <p><strong>diff</strong>的过程就是调用<code>patch</code>函数，比较新旧节点，一边比较一边给真实的<code>DOM</code>打补丁。在采取<code>diff</code>算法比较新旧节点的时候，比较只会在同层级进行。 在<code>patch</code>方法中，首先进行树级别的比较 <code>new Vnode</code>不存在就删除 <code>old Vnode</code> <code>old Vnode</code> 不存在就增加新的<code>Vnode</code> 都存在就执行diff更新 当确定需要执行diff算法时，比较两个<code>Vnode</code>，包括三种类型操作：属性更新，文本更新，子节点更新 新老节点均有子节点，则对子节点进行<code>diff</code>操作，调用<code>updatechidren</code> 如果老节点没有子节点而新节点有子节点，先清空老节点的文本内容，然后为其新增子节点 如果新节点没有子节点，而老节点有子节点的时候，则移除该节点的所有子节点 老新老节点都没有子节点的时候，进行文本的替换</p> <p><strong>updateChildren</strong> 将<code>Vnode</code>的子节点Vch和oldVnode的子节点oldCh提取出来。 <code>oldCh和vCh</code>各有两个头尾的变量<code>StartIdx和EndIdx</code>，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了<code>key</code>，就会用<code>key</code>进行比较，在比较的过程中，变量会往中间靠，一旦<code>StartIdx&gt;EndIdx</code>表明<code>oldCh和vCh</code>至少有一个已经遍历完了，就会结束比较。</p> <h5 id="_5-数据双向绑定的原理"><a href="#_5-数据双向绑定的原理" class="header-anchor">#</a> 5.数据双向绑定的原理</h5> <p>当一个<strong>Vue</strong>实例创建时，Vue会遍历data选项的属性，用 <strong>Object.defineProperty</strong> 将它们转为 getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。</p> <p>每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher重新计算，从而致使它关联的组件得以更新。</p> <h5 id="_6-强制更新视图的方法-2种以上"><a href="#_6-强制更新视图的方法-2种以上" class="header-anchor">#</a> 6.强制更新视图的方法（2种以上）</h5> <ol><li>this.$forceUpdate()</li> <li>this.$set('ssa', aaa)</li></ol> <h5 id="_8-vue3中setup-语法糖"><a href="#_8-vue3中setup-语法糖" class="header-anchor">#</a> 8.vue3中setup 语法糖</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>script setup<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><ol><li><p>组件自动注册</p> <p>在 script setup 中，引入的组件可以直接使用，无需再通过<code>components</code>进行注册，并且无法指定当前组件的名字，它会自动以文件名为主，也就是不用再写<code>name</code>属性了。</p></li> <li><p>使用 props</p></li></ol> <p>​	通过<code>defineProps</code>指定当前 props 类型，获得上下文的props对象。</p> <ol start="3"><li>使用 emits</li></ol> <p>​	使用<code>defineEmit</code>定义当前组件含有的事件，并通过返回的上下文去执行 emit。</p> <ol start="4"><li>获取 slots 和 attrs</li></ol> <p>​	可以通过<code>useContext</code>从上下文中获取 slots 和 attrs。不过提案在正式通过后，废除了这个语法，被拆分成了<code>useAttrs</code>和<code>useSlots</code>。</p> <h5 id="_9-vue3的钩子函数"><a href="#_9-vue3的钩子函数" class="header-anchor">#</a> 9.vue3的钩子函数</h5> <ul><li><code>beforeCreate</code> -&gt; 使用 <code>setup()</code></li> <li><code>created</code> -&gt; 使用 <code>setup()</code></li> <li><code>beforeMount</code> -&gt; <code>onBeforeMount</code></li> <li><code>mounted</code> -&gt; <code>onMounted</code></li> <li><code>beforeUpdate</code> -&gt; <code>onBeforeUpdate</code></li> <li><code>updated</code> -&gt; <code>onUpdated</code></li> <li><code>beforeDestroy</code> -&gt; <code>onBeforeUnmount</code></li> <li><code>destroyed</code> -&gt; <code>onUnmounted</code></li> <li><code>errorCaptured</code> -&gt; <code>onErrorCaptured</code></li></ul> <h5 id="_10-vuex和pinia的区别"><a href="#_10-vuex和pinia的区别" class="header-anchor">#</a> 10.vuex和pinia的区别</h5> <p>Vuex的优点</p> <ul><li>支持调试功能，如时间旅行和编辑</li> <li>适用于大型、高复杂度的Vue.js项目</li></ul> <p>Vuex的缺点</p> <ul><li>从 Vue 3 开始，getter 的结果不会像计算属性那样缓存</li> <li>Vuex 4有一些与类型安全相关的问题</li></ul> <p>Pinia的优点</p> <ul><li>完整的 TypeScript 支持：与在 Vuex 中添加 TypeScript 相比，添加 TypeScript 更容易</li> <li>极其轻巧（体积约 1KB）</li> <li>store 的 action 被调度为常规的函数调用，而不是使用 <code>dispatch</code> 方法或 <code>MapAction</code> 辅助函数，这在 Vuex 中很常见</li> <li>支持多个Store</li> <li>支持 Vue devtools、SSR 和 webpack 代码拆分</li></ul> <p>Pinia的缺点</p> <ul><li>不支持时间旅行和编辑等调试功能</li></ul> <h5 id="_11-vuex的构成及属性"><a href="#_11-vuex的构成及属性" class="header-anchor">#</a> 11.vuex的构成及属性</h5> <h5 id="_12-nexttick的原理"><a href="#_12-nexttick的原理" class="header-anchor">#</a> 12.$nextTick的原理</h5> <ol><li><code>nextTick</code>是<code>Vue</code>提供的一个全局<code>API</code>,是在下次<code>DOM</code>更新循环结束之后执行延迟回调，在修改数据之后使用<code>$nextTick</code>，则可以在回调中获取更新后的<code>DOM</code>；</li> <li>Vue在更新DOM时是异步执行的。只要侦听到数据变化，<code>Vue</code>将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个<code>watcher</code>被多次触发，只会被推入到队列中-次。这种在缓冲时去除重复数据对于避免不必要的计算和<code>DOM</code>操作是非常重要的。<code>nextTick</code>方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用；</li> <li>比如，我在干什么的时候就会使用nextTick，传一个回调函数进去，在里面执行dom操作即可；</li> <li>我也有简单了解<code>nextTick</code>实现，它会在<code>callbacks</code>里面加入我们传入的函数，然后用<code>timerFunc</code>异步方式调用它们，首选的异步方式会是<code>Promise</code>。这让我明白了为什么可以在<code>nextTick</code>中看到<code>dom</code>操作结果。</li></ol> <h5 id="_13-computed是计算用的-有缓冲-请问为什么有缓冲"><a href="#_13-computed是计算用的-有缓冲-请问为什么有缓冲" class="header-anchor">#</a> 13.computed是计算用的，有缓冲，请问为什么有缓冲？</h5> <ol><li><p>Computed也是响应式的</p> <p>Computed是响应式的，读取Computed会触发get，设置Computed会触发set</p></li> <li><p>Computed如何控制缓存</p></li></ol> <p>​	计算属性是有缓存的，比如某个计算属性C，它依赖data中的A，如果没有缓存的话，每次读取C时，C都回去读取A，从而触发A的get。多次触发A的get有时候是一个非常消耗性能的操	作，所以Computed必须要有缓存</p> <p>​	computed里面控制缓存最重要的一点就是脏数据标记为dirty, dirty是watcher的一个属性。</p> <p>​	当dirty为true时，读取computed会重新计算
​	当dirty为false时，读取computed会使用缓存</p> <ol start="3"><li>依赖的data发生变化，computed是如何更新的</li></ol> <p>​	页面P依赖计算属性C, 计算属性C又依赖data里面的A, computed更新步骤如下:</p> <p>​		由于C依赖了A, A可以收集到C的watcher</p> <p>​		当A发生变化时，会将watcher的脏数据标记位dirty设置为true</p> <p>​		并且A会收集到页面P的watcher，A通知P进行更新，从而页面P重新读取计算属性C, 由于此时dirty为true，此时的计算属性会重新计算。</p> <p>​		computed更新完毕，重新将脏数据标记位dirty设置为false，如果其依赖的A不发生改变，那下次再进入就会读取缓存。</p> <ol start="4"><li>计算属性C是如何让data中的A收集到页面P的watcher的
这其实是计算属性中一个非常巧妙的操作。来看一下核心的源码(已简化)</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createComputedGetter</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token comment">// 获取到相应 key 的 computed-watcher</span>
        <span class="token keyword">var</span> watcher <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_computedWatchers<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果 computed 依赖的数据变化，dirty 会变成true，</span>
        <span class="token comment">// 从而重新计算，然后更新缓存值 watcher.value</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">.</span>dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            watcher<span class="token punctuation">.</span><span class="token function">evaluate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>        
        <span class="token comment">// 这里是 月老computed 牵线的重点，让双方建立关系</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            watcher<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>        
        <span class="token keyword">return</span> watcher<span class="token punctuation">.</span>value
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="_14-vuex中mutation为什么只能是同步的-可以不可以改成异步的-如果可以-为什么还要设计一个action-如何实现的"><a href="#_14-vuex中mutation为什么只能是同步的-可以不可以改成异步的-如果可以-为什么还要设计一个action-如何实现的" class="header-anchor">#</a> 14.vuex中mutation为什么只能是同步的？可以不可以改成异步的？如果可以，为什么还要设计一个action?如何实现的？</h5> <ul><li>Mutation中是同步函数和Action中是异步函数，属于一种约定，为了更好的追踪vuex的状态变化，希望我们都按照这种原则进行开发</li> <li>Mutation必须是同步函数</li> <li>更改state的唯一方法是通过提交 mutation</li> <li>Action中不进行状态的直接更改，而是通过commit触发mutation</li> <li>mutation的触发通过store.commit来进行</li> <li>action的触发通过store.dispatch进行</li> <li>mutations里的同步意义在于，每个mutation执行完毕之后，可以得到对应的状态，使用devtools可以跟踪状态的变化</li></ul> <h5 id="_15-vue如何优化seo"><a href="#_15-vue如何优化seo" class="header-anchor">#</a> 15.vue如何优化SEO?</h5> <ol><li>SSR服务端渲染</li> <li>Nuxt静态化</li> <li>预渲染 prerender-spa-plugin</li> <li>使用Phantomjs针对爬虫做处理</li></ol> <h5 id="_16-watch不能深度监听-需要设置deep-这个是怎么实现的"><a href="#_16-watch不能深度监听-需要设置deep-这个是怎么实现的" class="header-anchor">#</a> 16.watch不能深度监听，需要设置deep，这个是怎么实现的？</h5> <ol><li>监听数据改变时， watch是如何工作的？</li></ol> <p>​	Vue会把数据设置响应式，即设置他的 get 和 set 当数据被读取，get被触发，然后收集到读取他的东西，保存到依赖收集器 当数据被改变，set被触发，然后通知曾经读取他的东西	进行更新。
​    watch 在一开始初始化的时候，会读取一遍监听的数据的值，于是，此时那个数据就收集到 watch 的 watcher了,然后你给 watch 设置的 handler ，watch会放入watcher 的更	新函数中 当 数据改变时，通知  watch 的 watcher 进行更新，于是 你设置的 handler 就被调用了.</p> <ol start="2"><li>设置了immediate ， watch是如何工作的？</li></ol> <p>​	设置了 immediate 时，就不需要在数据改变的时候才会触发。 而是在 初始化 watch 时，在读取了 监听的数据的值 之后，便立即调用一遍你设置的监听回调，然后传入刚读取的值.</p> <ol start="3"><li>设置了deep ， watch是如何工作的？</li></ol> <p>​	从vue源码可以看到， 当存在deep属性时，会执行traverse方法。 简单来讲，就是递归收集对象或数组的子属性值。</p> <h5 id="_17-发布-订阅者模式的原理和实现"><a href="#_17-发布-订阅者模式的原理和实现" class="header-anchor">#</a> 17.发布/订阅者模式的原理和实现？</h5> <p><strong>观察者模式</strong></p> <p>当对象之间存在一对多的依赖关系时，其中一个对象的状态发生改变，所有依赖它的对象都会收到通知</p> <p>在观察者模式中，只有两种主体：目标对象 (<code>Object</code>) 和 观察者 (<code>Observer</code>)。</p> <p>目标对象 <code>Subject</code>:</p> <ul><li>维护观察者列表 <code>observerList</code></li> <li>定义添加观察者的方法</li> <li>当自身发生变化后，通过调用自己的 <code>notify</code> 方法依次通知每个观察者执行 <code>update</code> 方法</li></ul> <p>观察者 <code>Observer</code> 需要实现 <code>update</code> 方法，供目标对象调用。<code>update</code>方法中可以执行自定义的业务逻辑</p> <p>小案例：</p> <p>比如你要应聘阿里巴巴的前端工程师，结果阿里巴巴 HR 告诉你没坑位了，留下你的电话，等有坑位联系你。于是，你美滋滋的留下了联系方式。殊不知，HR 已经留下了好多联系方式。好在</p> <p>2022 年 2 月 30 号那天，阿里巴巴有了前端工程师的坑位，HR 挨着给留下的联系方式联系了一通。</p> <p>案例中阿里巴巴就是目标对象 <code>Subject</code> ，联系方式列表就是用来维护观察者的 <code>observerList</code> ，根据前端职位的有无来调用 <code>notify</code> 方法。</p> <p><strong>发布订阅模式</strong></p> <p>基于一个事件（主题）通道，希望接收通知的对象 <code>Subscriber</code> 通过自定义事件订阅主题，被激活事件的对象 <code>Publisher</code> 通过发布主题事件的方式通知各个订阅该主题的</p> <p><code>Subscriber</code> 对象。</p> <p>因此发布订阅模式与观察者模式相比，发布订阅模式中有三个角色，发布者 <code>Publisher</code> ，事件调度中心 <code>Event Channel</code> ，订阅者 <code>Subscriber</code> 。</p> <p>小案例：</p> <p>以目前的<strong>热播剧开端</strong>为例，临近过年，摸鱼的心思越来越重，每天就迫不及待的等开端更新，想在开端更新的第一刻就开始看剧，那你会怎么做那？总不能时时刻刻刷新页面吧。平台提供了消息</p> <p>订阅功能，如果你选择订阅，平台更新开端后，会第一时间发消息通知你，订阅后，你就可以愉快的追剧了。</p> <p>上面案例中，开端就是发布者 <code>Publisher</code>，追剧人就是订阅者 <code>Subscribe</code>，平台则承担了事件通道 <code>Event Channel</code> 功能。</p> <p><strong>发布-订阅模式用来处理不同系统组件的信息交流，即使这些组件不知道对方的存在</strong>。</p> <table><thead><tr><th>设计模式</th> <th>观察者模式</th> <th>发布订阅模式</th></tr></thead> <tbody><tr><td>主体</td> <td>Object观察者、Subject目标对象</td> <td>Publisher发布者、Event Channel事件中心、Subscribe订阅者</td></tr> <tr><td>主体关系</td> <td>Subject中通过observerList记录ObServer</td> <td>Publisher和Subscribe不想不知道对方，通过中介联系</td></tr> <tr><td>优点</td> <td>角色明确，Subject和Object要遵循约定的成员方法</td> <td>松散耦合，灵活度高，通常应用在异步编程中</td></tr> <tr><td>缺点</td> <td>紧耦合</td> <td>当事件类型变多时，会增加维护成本</td></tr> <tr><td>使用案例</td> <td>双向数据绑定</td> <td>事件总线EventBus</td></tr></tbody></table> <h5 id="_18-vue-component-和vue-prototype和vue-use-的区别"><a href="#_18-vue-component-和vue-prototype和vue-use-的区别" class="header-anchor">#</a> 18. vue.component()和vue.prototype和vue.use()的区别</h5> <h5 id="_19-v-if和v-show在虚拟dom方面是怎么做的区分"><a href="#_19-v-if和v-show在虚拟dom方面是怎么做的区分" class="header-anchor">#</a> 19. v-if和v-show在虚拟DOM方面是怎么做的区分？</h5> <h5 id="_20-怎么把一个组件挂载到原型上-内部进行了什么转化"><a href="#_20-怎么把一个组件挂载到原型上-内部进行了什么转化" class="header-anchor">#</a> 20.怎么把一个组件挂载到原型上，内部进行了什么转化？</h5> <p>1.写一个js文件, 在js文件里写方法 ,然后用export default导出
2. 在main.js中引入js中导出的方法 然后就是Vue.prototype.方法 = 引入的方法
3. 在组件里就直接this.方法就可以用了</p> <p>当要封装的方法比较简单的时候，可以直接在main.js中这样写：</p> <p>Vue.prototype.方法 = 引入的方法</p> <h4 id="webpack"><a href="#webpack" class="header-anchor">#</a> WEBPACK</h4> <h5 id="_1-webpack执行流程"><a href="#_1-webpack执行流程" class="header-anchor">#</a> 1.webpack执行流程</h5> <p><code>初始化参数：</code>  从配置文件和shell 语句中读取与合并参数，得到最终的参数。</p> <p><code>开始编译：</code>  用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行 compiler 对象的 run 方法开始执行编译。</p> <p><code>确定入口：</code> 根据配置中的 entry 找出所有的入口文件。</p> <p><code>编译模块：</code> 从入口文件出发，调用所有配置的 Loader 对模块进行编译，找出该模块依赖的模块，再递归本步骤直到所有依赖文件都经过本步骤的处理。</p> <p><code>完成模块编译</code>： 在经过第 4 步使用 Loader 编译完所有模块之后，得到每个模块被编译后的最终内容以及它们之间的依赖关系。</p> <p><code>输出资源：</code> 根据入口和模块之间的关系，组装成一个个包含多个模块的 chunk，再把每个 chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会。</p> <p><code>输出完成：</code> 在确定输出内容之后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</p> <h5 id="_2-loaders和plugins的区别、实现原理"><a href="#_2-loaders和plugins的区别、实现原理" class="header-anchor">#</a> 2.loaders和plugins的区别、实现原理</h5> <p><code>Loader</code> 本质就是一个函数，在该函数对接收到的内容进行转换，返回转换后的结果。因为 webpack 只认识 js，所以，你也可以将 Loader 称之为“翻译官”，对其他类型的资源进行转译的预处理工作。</p> <p><code>Plugin</code> 直译为插件，基于事件流框架 <code>Tapable</code>。Plugin 可以扩展 webpack 的功能，让 webpack 具有更多的灵活性。在 Webpack 运行的生命周期中会广播出许多事件，Plugin可以监听这些事件，在合适的时机通过 webpack 提供的 API 改变输出结果。</p> <h5 id="_3-loaders的执行顺序"><a href="#_3-loaders的执行顺序" class="header-anchor">#</a> 3.loaders的执行顺序</h5> <p>从右向左</p> <h5 id="_4-webpack怎么优化代码"><a href="#_4-webpack怎么优化代码" class="header-anchor">#</a> 4.webpack怎么优化代码</h5> <ol><li>JS 压缩</li> <li>CSS 压缩</li> <li>代码分离</li></ol> <p>​	代码分离能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，可以缩短页面加载时间。</p> <ol start="4"><li>抽离重复代码</li></ol> <h5 id="_5-rollup和webpack的区别-有什么优势"><a href="#_5-rollup和webpack的区别-有什么优势" class="header-anchor">#</a> 5.rollup和webpack的区别，有什么优势</h5> <p>Webpack:</p> <ol><li><strong>代码分割</strong>可以将你的 app 分割成许多个容易管理的分块，这些分块能够在用户使用你的 app 时按需加载。这意味着你的用户可以有更快的交互体验。因为访问那些没有使用代码分割的应用时，必须要等待整个应用都被下载并解析完成。当然，你<strong>也可以</strong>自己手动去进行代码分割，但是……总之，祝你好运。</li> <li><strong>静态资源</strong>的导入</li> <li>，就和其它的模块、节点一样能够进行依赖管理。因此，我们再也不用小心翼翼地将各个静态文件放在特定的文件夹中，然后再去用脚本给文件 URL 加上哈希串了。Webpack 已经帮你完成了这一切。</li></ol> <p>Rollup:</p> <ol><li>它利用 ES2015 模块的巧妙设计，尽可能高效地构建精简且易分发的 JavaScript 库。而其它的模块打包器（包括 Webpack在内）都是通过将模块分别封装进函数中，然将这些函数通过能在浏览器中实现的 <code>require</code> 方法打包，最后依次处理这些函数。在你需要实现按需加载的时候，这种做法非常的方便，但是这样做引入了很多无关代码，比较浪费资源。当<a href="https://link.juejin.cn?target=https%3A%2F%2Fnolanlawson.com%2F2016%2F08%2F15%2Fthe-cost-of-small-modules%2F" target="_blank" rel="noopener noreferrer">你有很多模块要打包的时候，这种情况会变得更糟糕<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</li> <li>代码分割是一个很棘手的问题，而 Rollup 并不能做到这一点。同样的，Rollup 也不支持模块热替换（HMR）。而且对于打算使用 Rollup 的人来说，还有一个最大的痛点：它通过<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Frollup%2Frollup-plugin-commonjs" target="_blank" rel="noopener noreferrer">插件<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>处理大多数 CommonJS 文件的时候，一些代码将无法被翻译为 ES2015。</li></ol> <h5 id="_6-loaders是怎么实现的-怎么写一个loaders"><a href="#_6-loaders是怎么实现的-怎么写一个loaders" class="header-anchor">#</a> 6.loaders是怎么实现的？怎么写一个loaders？</h5> <h5 id="_7-pnpm的优势和npm、yarn有什么不同"><a href="#_7-pnpm的优势和npm、yarn有什么不同" class="header-anchor">#</a> 7.pnpm的优势和npm、yarn有什么不同？</h5> <ul><li>npm/yarn在不同项目依赖同一个包的情况下，会将这个包安装多次在每个项目中，而pnpm安装的包会存储在可寻址的磁盘中，在多个项目同时引用时，只需要用一个硬链接指向该地址就可以使用，大大节约了磁盘空间</li> <li>当依赖了同一个包的不同版本时，只对变更的文件进行更新，不需要重复下载没有变更的部分，对于时间和空间</li> <li>算法比 npm/yarn 的扁平化算法简单很多，节省时间</li></ul> <h5 id="_8-webpack打包项目和组件库有什么区别-做哪些优化"><a href="#_8-webpack打包项目和组件库有什么区别-做哪些优化" class="header-anchor">#</a> 8.webpack打包项目和组件库有什么区别？做哪些优化？</h5> <h5 id="_9-webpack优化策略"><a href="#_9-webpack优化策略" class="header-anchor">#</a> 9.webpack优化策略？</h5> <ul><li>速度分析</li></ul> <p>webpack 有时候打包很慢，而我们在项目中可能用了很多的 plugin 和 loader ，想知道到底是哪个环节慢，下面这个插件可以计算 plugin 和 loader 的耗时。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">yarn</span> <span class="token function">add</span> -D speed-measure-webpack-plugin
</code></pre></div><p>分析每个插件和 loader 的耗时情况 知道了具体 loader 和 plugin 的耗时情况，我们就可以“对症下药”了</p> <ul><li>体积分析</li></ul> <p>打包后的体积优化是一个可以着重优化的点，比如引入的一些第三方组件库过大，这时就要考虑是否需要寻找替代品了</p> <ul><li>多进程/多实例构建</li></ul> <p>大家都知道 webpack 是运行在 node 环境中，而 node 是单线程的。 webpack 的打包过程是 io 密集和计算密集型的操作，如果能同时 fork 多个进程并行处理各个任务，将会有效的</p> <p>缩短构建时间。</p> <p>平时用的比较多的两个是 thread-loader 和 HappyPack 。</p> <ul><li>预编译资源模块</li></ul> <p>在使用 webpack 进行打包时候，对于依赖的第三方库，比如 vue ， vuex 等这些不会修改的依赖，我们可以让它和我们自己编写的代码分开打包，这样做的好处是每次更改我本地代码的文</p> <p>件的时候， webpack 只需要打包我项目本身的文件代码，而不会再去编译第三方库。</p> <p>那么第三方库在第一次打包的时候只打包一次，以后只要我们不升级第三方包的时候，那么 webpack 就不会对这些库去打包，这样的可以快速的提高打包的速度。其实也就是 预编译资源模块</p> <ul><li>利用缓存提升二次构建速度</li></ul> <p>一般来说，对于静态资源，我们都希望浏览器能够进行缓存，那样以后进入页面就可以直接使用缓存资源，页面打开速度会显著加快，既提高了用户的体验也节省了宽带资源。</p> <ul><li>缩小构建目标/减少文件搜索范围</li></ul> <p>有时候我们的项目中会用到很多模块，但有些模块其实是不需要被解析的。这时我们就可以通过缩小构建目标或者减少文件搜索范围的方式来对构建做适当的优化。</p> <h4 id="git"><a href="#git" class="header-anchor">#</a> GIT</h4> <h5 id="_1-git相关命令"><a href="#_1-git相关命令" class="header-anchor">#</a> 1.git相关命令</h5> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment">#git提交命令</span>
<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span> - 添加文件到暂存区。
<span class="token function">git</span> commit - 将暂存区内容添加到仓库中。


<span class="token function">git</span> commit -m <span class="token punctuation">[</span>message<span class="token punctuation">]</span>
$ <span class="token function">git</span> commit -a


<span class="token function">git</span> <span class="token function">add</span> -A  提交所有变化

<span class="token function">git</span> <span class="token function">add</span> -u  提交被修改<span class="token punctuation">(</span>modified<span class="token punctuation">)</span>和被删除<span class="token punctuation">(</span>deleted<span class="token punctuation">)</span>文件，不包括新文件<span class="token punctuation">(</span>new<span class="token punctuation">)</span>

<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>  提交新文件<span class="token punctuation">(</span>new<span class="token punctuation">)</span>和被修改<span class="token punctuation">(</span>modified<span class="token punctuation">)</span>文件，不包括被删除<span class="token punctuation">(</span>deleted<span class="token punctuation">)</span>文件

<span class="token comment">#使用 git checkout –orphan new_branch ,基于当前分支创建一个独立的分支new_branch；</span>
<span class="token function">git</span> checkout --orphan new_branch
<span class="token comment">#添加所有文件变化至暂存空间</span>
<span class="token function">git</span> <span class="token function">add</span> -A
<span class="token comment">#提交并添加提交记录</span>
<span class="token function">git</span> commit -am <span class="token string">&quot;commit clear&quot;</span>
<span class="token comment">#删除当前分支</span>
<span class="token function">git</span> branch -D master
<span class="token comment">#重新命名当前独立分支为 master</span>
<span class="token function">git</span> branch -m master
<span class="token comment">#推送到远端分支(-f 是 –force 的缩写, 可能会造成代码被覆盖)</span>
<span class="token function">git</span> push -f origin master

<span class="token function">git</span> pull
在目录下执行以下语句后，删除目录重新克隆以下就只有最新版本了。

</code></pre></div><h5 id="_2-git怎么合并单个文件"><a href="#_2-git怎么合并单个文件" class="header-anchor">#</a> 2.git怎么合并单个文件</h5> <p>分支A_bracn和B_branch，只想将A_branch分支的某个文件f.txt合并到B_branch分支上。
git checkout A_branch</p> <p>git checkout --patch B_branch f.txt</p> <p>第一个命令： 切换到A分支；</p> <p>第二个命令：合并B分支上f文件到A分支上，将B分支上 f 文件追加补丁到A分支上 f文件。你可以接受或者拒绝补丁内容。</p> <p>如果只是简单的将A_branch分支的文件f.txt copy到B_branch分支上；<br>
git checkout B_branch
cd path/to/f.txt
git checkout A_bracn f.txt</p> <h5 id="_3-git-rebase"><a href="#_3-git-rebase" class="header-anchor">#</a> 3. git rebase</h5> <ol><li>合并多个commit为一个完整commit</li></ol> <div class="language-shell extra-class"><pre class="language-shell"><code>  <span class="token function">git</span> rebase -i  <span class="token punctuation">[</span>startpoint<span class="token punctuation">]</span>  <span class="token punctuation">[</span>endpoint<span class="token punctuation">]</span>
</code></pre></div><ol start="2"><li>将某一段commit粘贴到另一个分支上</li></ol> <p><img src="https://upload-images.jianshu.io/upload_images/2147642-0de010746cb78401.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/808/format/webp" alt="img"></p> <div class="language-shell extra-class"><pre class="language-shell"><code>    <span class="token function">git</span> rebase   <span class="token punctuation">[</span>startpoint<span class="token punctuation">]</span>   <span class="token punctuation">[</span>endpoint<span class="token punctuation">]</span>  --onto  <span class="token punctuation">[</span>branchName<span class="token punctuation">]</span>
</code></pre></div><h4 id="uni-app"><a href="#uni-app" class="header-anchor">#</a> UNI-APP</h4> <h5 id="_1-uni-app的钩子函数"><a href="#_1-uni-app的钩子函数" class="header-anchor">#</a> 1.uni-app的钩子函数</h5> <ol><li><a href="https://uniapp.dcloud.io/collocation/frame/lifetime?id=%E5%BA%94%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" target="_blank" rel="noopener noreferrer">应用生命周期<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <table><thead><tr><th>函数名</th> <th>说明</th></tr></thead> <tbody><tr><td>onLaunch</td> <td>当<code>uni-app</code> 初始化完成时触发（全局只触发一次）</td></tr> <tr><td>onShow</td> <td>当 <code>uni-app</code> 启动，或从后台进入前台显示</td></tr> <tr><td>onHide</td> <td>当 <code>uni-app</code> 从前台进入后台</td></tr> <tr><td>onUniNViewMessage</td> <td>对 <code>nvue</code> 页面发送的数据进行监听，可参考 <a href="https://uniapp.dcloud.io/use-weex?id=nvue-%E5%90%91-vue-%E9%80%9A%E8%AE%AF" target="_blank" rel="noopener noreferrer">nvue 向 vue 通讯<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></td></tr></tbody></table> <ol start="2"><li><a href="https://uniapp.dcloud.io/collocation/frame/lifetime?id=%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" target="_blank" rel="noopener noreferrer">页面生命周期<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <table><thead><tr><th>函数名</th> <th>说明</th> <th>平台差异说明</th> <th>最低版本</th></tr></thead> <tbody><tr><td>onLoad</td> <td>监听页面加载，其参数为上个页面传递的数据，参数类型为Object（用于页面传参），参考<a href="https://uniapp.dcloud.io/api/router?id=navigateto" target="_blank" rel="noopener noreferrer">示例<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></td> <td></td> <td></td></tr> <tr><td>onShow</td> <td>监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面</td> <td></td> <td></td></tr> <tr><td>onReady</td> <td>监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发</td> <td></td> <td></td></tr> <tr><td>onHide</td> <td>监听页面隐藏</td> <td></td> <td></td></tr> <tr><td>onUnload</td> <td>监听页面卸载</td> <td></td> <td></td></tr> <tr><td>onResize</td> <td>监听窗口尺寸变化</td> <td>5+App、微信小程序</td> <td></td></tr> <tr><td>onPullDownRefresh</td> <td>监听用户下拉动作，一般用于下拉刷新，参考<a href="https://uniapp.dcloud.io/api/ui/pulldown" target="_blank" rel="noopener noreferrer">示例<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></td> <td></td> <td></td></tr> <tr><td>onReachBottom</td> <td>页面滚动到底部的事件（不是scroll-view滚到底），常用于下拉下一页数据。具体见下方注意事项</td> <td></td> <td></td></tr> <tr><td>onTabItemTap</td> <td>点击 tab 时触发，参数为Object，具体见下方注意事项</td> <td>微信小程序、百度小程序、H5、5+App（自定义组件模式）</td> <td></td></tr> <tr><td>onShareAppMessage</td> <td>用户点击右上角分享</td> <td>微信小程序、百度小程序、头条小程序、支付宝小程序</td> <td></td></tr> <tr><td>onPageScroll</td> <td>监听页面滚动，参数为Object</td> <td></td> <td></td></tr> <tr><td>onNavigationBarButtonTap</td> <td>监听原生标题栏按钮点击事件，参数为Object</td> <td>5+ App、H5</td> <td></td></tr> <tr><td>onBackPress</td> <td>监听页面返回，返回 event = {from:backbutton、 navigateBack} ，backbutton 表示来源是左上角返回按钮或 android 返回键；navigateBack表示来源是 uni.navigateBack ；详细说明及使用：<a href="http://ask.dcloud.net.cn/article/35120" target="_blank" rel="noopener noreferrer">onBackPress 详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></td> <td>5+App、H5</td> <td></td></tr> <tr><td>onNavigationBarSearchInputChanged</td> <td>监听原生标题栏搜索输入框输入内容变化事件</td> <td>5+App、H5</td> <td>1.6.0</td></tr> <tr><td>onNavigationBarSearchInputConfirmed</td> <td>监听原生标题栏搜索输入框搜索事件，用户点击软键盘上的“搜索”按钮时触发。</td> <td>5+App、H5</td> <td>1.6.0</td></tr> <tr><td>onNavigationBarSearchInputClicked</td> <td>监听原生标题栏搜索输入框点击事件</td> <td>5+App、H5</td> <td>1.6.0</td></tr></tbody></table> <h4 id="自动化测试"><a href="#自动化测试" class="header-anchor">#</a> 自动化测试</h4> <h5 id="_1-说说单元测试"><a href="#_1-说说单元测试" class="header-anchor">#</a> 1.说说单元测试</h5></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vue-press-md/面试经典题型/1_面试经典题型.html" class="prev">
        闭包、作用域等
      </a></span> <span class="next"><a href="/vue-press-md/前端单元测试/1_前端单元测试.html">
        前端单元测试
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vue-press-md/assets/js/app.14c5cd4c.js" defer></script><script src="/vue-press-md/assets/js/2.ab91b6d3.js" defer></script><script src="/vue-press-md/assets/js/41.8261988b.js" defer></script>
  </body>
</html>
