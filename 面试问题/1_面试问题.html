<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试问题汇总 | OrangeWind</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="学习 复习 面试">
    
    <link rel="preload" href="/vue-press-md/assets/css/0.styles.80c6c626.css" as="style"><link rel="preload" href="/vue-press-md/assets/js/app.4de37d2a.js" as="script"><link rel="preload" href="/vue-press-md/assets/js/2.ab91b6d3.js" as="script"><link rel="preload" href="/vue-press-md/assets/js/41.50d2e677.js" as="script"><link rel="prefetch" href="/vue-press-md/assets/js/10.316b3567.js"><link rel="prefetch" href="/vue-press-md/assets/js/11.386338f0.js"><link rel="prefetch" href="/vue-press-md/assets/js/12.36d14a37.js"><link rel="prefetch" href="/vue-press-md/assets/js/13.db8f9e92.js"><link rel="prefetch" href="/vue-press-md/assets/js/14.37839f97.js"><link rel="prefetch" href="/vue-press-md/assets/js/15.3099003c.js"><link rel="prefetch" href="/vue-press-md/assets/js/16.63d87d6e.js"><link rel="prefetch" href="/vue-press-md/assets/js/17.c17bbe0c.js"><link rel="prefetch" href="/vue-press-md/assets/js/18.59dc9870.js"><link rel="prefetch" href="/vue-press-md/assets/js/19.615a160d.js"><link rel="prefetch" href="/vue-press-md/assets/js/20.18a2424d.js"><link rel="prefetch" href="/vue-press-md/assets/js/21.2c8a1481.js"><link rel="prefetch" href="/vue-press-md/assets/js/22.7ba7c367.js"><link rel="prefetch" href="/vue-press-md/assets/js/23.c4779a4e.js"><link rel="prefetch" href="/vue-press-md/assets/js/24.7bf3690a.js"><link rel="prefetch" href="/vue-press-md/assets/js/25.d62c5bde.js"><link rel="prefetch" href="/vue-press-md/assets/js/26.6d8e4d91.js"><link rel="prefetch" href="/vue-press-md/assets/js/27.068bddbf.js"><link rel="prefetch" href="/vue-press-md/assets/js/28.798cbf6a.js"><link rel="prefetch" href="/vue-press-md/assets/js/29.91160595.js"><link rel="prefetch" href="/vue-press-md/assets/js/3.fb28e9ff.js"><link rel="prefetch" href="/vue-press-md/assets/js/30.162f0384.js"><link rel="prefetch" href="/vue-press-md/assets/js/31.0a649129.js"><link rel="prefetch" href="/vue-press-md/assets/js/32.ef83b440.js"><link rel="prefetch" href="/vue-press-md/assets/js/33.dd41a5bc.js"><link rel="prefetch" href="/vue-press-md/assets/js/34.60454519.js"><link rel="prefetch" href="/vue-press-md/assets/js/35.ea050dc6.js"><link rel="prefetch" href="/vue-press-md/assets/js/36.03b7fd6b.js"><link rel="prefetch" href="/vue-press-md/assets/js/37.0a2c12d9.js"><link rel="prefetch" href="/vue-press-md/assets/js/38.025548e6.js"><link rel="prefetch" href="/vue-press-md/assets/js/39.187bd986.js"><link rel="prefetch" href="/vue-press-md/assets/js/4.b7d0708f.js"><link rel="prefetch" href="/vue-press-md/assets/js/40.45164e7f.js"><link rel="prefetch" href="/vue-press-md/assets/js/5.9e2f4ca7.js"><link rel="prefetch" href="/vue-press-md/assets/js/6.c7b54f12.js"><link rel="prefetch" href="/vue-press-md/assets/js/7.b10070a8.js"><link rel="prefetch" href="/vue-press-md/assets/js/8.d6793119.js"><link rel="prefetch" href="/vue-press-md/assets/js/9.1d36f099.js">
    <link rel="stylesheet" href="/vue-press-md/assets/css/0.styles.80c6c626.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vue-press-md/" class="home-link router-link-active"><!----> <span class="site-name">OrangeWind</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>TypeScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/pages/e7c319/" class="sidebar-link">1_安装</a></li><li><a href="/vue-press-md/pages/6c55ba/" class="sidebar-link">2_基本类型</a></li><li><a href="/vue-press-md/pages/2bc780/" class="sidebar-link">3_接口</a></li><li><a href="/vue-press-md/pages/005633/" class="sidebar-link">4_类</a></li><li><a href="/vue-press-md/pages/5e1100/" class="sidebar-link">5_函数</a></li><li><a href="/vue-press-md/pages/2bf48b/" class="sidebar-link">6_泛型</a></li><li><a href="/vue-press-md/pages/c2333c/" class="sidebar-link">7_其他</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue3快速上手</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/pages/b9888e/" class="sidebar-link">1_创建vue3项目</a></li><li><a href="/vue-press-md/pages/835280/" class="sidebar-link">2_Composition API</a></li><li><a href="/vue-press-md/pages/c4f20f/" class="sidebar-link">3_Composition API其它</a></li><li><a href="/vue-press-md/pages/8aa12e/" class="sidebar-link">4_手写组合API</a></li><li><a href="/vue-press-md/pages/25827d/" class="sidebar-link">5_新组件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>面试相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/pages/276b03/" class="sidebar-link">1_HTML、CSS相关</a></li><li><a href="/vue-press-md/pages/3e0807/" class="sidebar-link">2_JS相关</a></li><li><a href="/vue-press-md/pages/04db0e/" class="sidebar-link">3_Vue2</a></li><li><a href="/vue-press-md/pages/0ae77b/" class="sidebar-link">4_网络安全、HTTP协议</a></li><li><a href="/vue-press-md/pages/7d684d/" class="sidebar-link">5_前端工程化</a></li><li><a href="/vue-press-md/pages/32929a/" class="sidebar-link">6_前端性能优化</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>面试手写系列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/pages/169a00/" class="sidebar-link">1_防抖节流</a></li><li><a href="/vue-press-md/pages/94a8b1/" class="sidebar-link">2_对象浅拷贝</a></li><li><a href="/vue-press-md/pages/6ed30a/" class="sidebar-link">3_对象深拷贝</a></li><li><a href="/vue-press-md/pages/b3288c/" class="sidebar-link">4_数组去重</a></li><li><a href="/vue-press-md/pages/ec5aa8/" class="sidebar-link">5_对象去重</a></li><li><a href="/vue-press-md/pages/b46fd9/" class="sidebar-link">6_数组扁平化</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>面试经典题型</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/面试经典题型/1_面试经典题型.html" class="sidebar-link">闭包、作用域等</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>面试问题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/面试问题/1_面试问题.html" class="active sidebar-link">面试问题汇总</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端单元测试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/前端单元测试/1_前端单元测试.html" class="sidebar-link">前端单元测试</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>力扣算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/力扣算法/1_力扣算法.html" class="sidebar-link">力扣算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>补充</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/补充/1_补充.html" class="sidebar-link">补充</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>抓包工具</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/抓包工具/1_抓包工具.html" class="sidebar-link">抓包工具</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>通用小工具系列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-press-md/通用小工具系列/1_通用小工具系列.html" class="sidebar-link">通用小工具系列</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="面试问题汇总"><a href="#面试问题汇总" class="header-anchor">#</a> 面试问题汇总</h3> <h4 id="css"><a href="#css" class="header-anchor">#</a> CSS</h4> <h5 id="_1-grid布局"><a href="#_1-grid布局" class="header-anchor">#</a> 1.grid布局</h5> <p>display 属性</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token property">display</span><span class="token punctuation">:</span>grid 指定一个容器采用网格布局
grid-template-columns 属性定义每一列的列宽
grid-template-rows 属性定义每一行的行高
<span class="token function">repeat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值
auto-fill 关键字表示自动填充
fr 关键字，表示比例关系，如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。
<span class="token function">minmax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值
auto 关键字表示由浏览器自己决定长度
grid-row-gap 属性设置行与行的间隔（行间距）
grid-column-gap属性设置列与列的间隔（列间距）
grid-gap 属性是grid-column-gap和grid-row-gap的合并简写形式
grid-template-areas 属性用于定义区域
grid-auto-flow 属性决定，默认值是row，即<span class="token string">&quot;先行后列&quot;</span>。也可以将它设成column，变成<span class="token string">&quot;先列后行&quot;</span>

justify-items 属性设置单元格内容的水平位置（左中右）
align-items 属性设置单元格内容的垂直位置（上中下）
place-items 属性是align-items属性和justify-items属性的合并简写形式
start：对齐单元格的起始边缘。
end：对齐单元格的结束边缘。
center：单元格内部居中。
stretch：拉伸，占满单元格的整个宽度（默认值）。

justify-content属性是整个内容区域在容器里面的水平位置（左中右）
align-content属性是整个内容区域的垂直位置（上中下）
place-content属性是align-content属性和justify-content属性的合并简写形式
start - 对齐容器的起始边框
end - 对齐容器的结束边框
center - 容器内部居中
stretch - 项目大小没有指定时，拉伸占据整个网格容器
space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍
space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔
space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔

grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。
grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式
</code></pre></div><p>项目属性</p> <div class="language-css extra-class"><pre class="language-css"><code>grid-column-start 属性：左边框所在的垂直网格线
grid-column-end 属性：右边框所在的垂直网格线
grid-row-start 属性：上边框所在的水平网格线
grid-row-end 属性：下边框所在的水平网格线
grid-column 属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。
grid-area 属性指定项目放在哪一个区域

justify-self 属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。
align-self 属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。
start：对齐单元格的起始边缘。
end：对齐单元格的结束边缘。
center：单元格内部居中。
stretch：拉伸，占满单元格的整个宽度（默认值）。
</code></pre></div><p>示例</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">div</span> <span class="token punctuation">{</span>
    <span class="token property">display</span><span class="token punctuation">:</span> grid
<span class="token punctuation">}</span>

<span class="token selector">默认情况下，容器元素都是块级元素，但也可以设成行内元素。
div</span> <span class="token punctuation">{</span>
    <span class="token property">display</span><span class="token punctuation">:</span> inline-grid
<span class="token punctuation">}</span>

<span class="token selector">注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。

.container</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>
  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> 100px 100px 100px<span class="token punctuation">;</span>
  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> 100px 100px 100px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">上面代码指定了一个三行三列的网格，列宽和行高都是100px。除了使用绝对单位，也可以使用百分比：
.container</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>
  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> 33.33% 33.33% 33.33%<span class="token punctuation">;</span>
  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> 33.33% 33.33% 33.33%<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">上面的代码用repeat()改写如下：
.container</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>
  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> <span class="token function">repeat</span><span class="token punctuation">(</span>3<span class="token punctuation">,</span> 33.33%<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> <span class="token function">repeat</span><span class="token punctuation">(</span>3<span class="token punctuation">,</span> 33.33%<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.container</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>
  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> <span class="token function">repeat</span><span class="token punctuation">(</span>auto-fill<span class="token punctuation">,</span> 100px<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">上面代码表示每列宽度100px，然后自动填充，直到容器不能放置更多的列。

.container</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>
  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> 150px 1fr 2fr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
上面代码表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。

<span class="token property">grid-template-columns</span><span class="token punctuation">:</span> 1fr 1fr <span class="token function">minmax</span><span class="token punctuation">(</span>100px<span class="token punctuation">,</span> 1fr<span class="token punctuation">)</span><span class="token punctuation">;</span>
上面代码中，<span class="token function">minmax</span><span class="token punctuation">(</span>100px<span class="token punctuation">,</span> 1fr<span class="token punctuation">)</span>表示列宽不小于100px，不大于1fr

<span class="token property">grid-template-columns</span><span class="token punctuation">:</span> 100px auto 100px<span class="token punctuation">;</span>
上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度。
</code></pre></div><h5 id="_2-瀑布流"><a href="#_2-瀑布流" class="header-anchor">#</a> 2.瀑布流</h5> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c8d4fb3872e4636a3cfa6128a48e128~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">方法一：column实现

- column-count: 定义屏幕分为多少列
- column-gap: 定义列与列之间的距离

body</span><span class="token punctuation">{</span>
    <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">list-style</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">#box</span><span class="token punctuation">{</span>
    <span class="token property">margin</span><span class="token punctuation">:</span> 40px<span class="token punctuation">;</span>
    <span class="token property">column-count</span><span class="token punctuation">:</span> 5<span class="token punctuation">;</span>
    <span class="token property">column-gap</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">#box &gt; li &gt; img</span><span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

优点：

实现简单
图片自动填充不用考虑图片加载状态

缺点：

兼容性差
排列规律永远都是先上下在左右，无法控制
</code></pre></div><div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">方法二：flex布局实现

body</span><span class="token punctuation">{</span>
    <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">list-style</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">#box</span><span class="token punctuation">{</span>
    <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
    <span class="token property">flex-flow</span><span class="token punctuation">:</span> column wrap<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 2000px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">#box &gt; li</span><span class="token punctuation">{</span>
    <span class="token property">margin</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span>100% / 4 - 20px<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">#box &gt; li &gt; img</span><span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

优点：
    实现相对简单
    图片自动填充不用考虑图片加载状态
    顺序在一定程度上可以改变

缺点：
	高度是固定的
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code>方法三：<span class="token constant">JS</span>实现

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Waterfall</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
    * $el：父容器
    * width：每张图片宽度
    * items：所有子元素
    * H：存储每一列的高度
    * flag：虚拟DOM节点集合
    * */</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>$el <span class="token operator">=</span> <span class="token keyword">null</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">4</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>gap <span class="token operator">=</span> <span class="token number">10</span>
        Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token constant">H</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token keyword">null</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'ok'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">.</span>children<span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>flag <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//创建一个空白文档</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">.</span>clientWidth <span class="token operator">/</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token constant">H</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">&quot;&quot;</span>
    <span class="token punctuation">}</span>

    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> <span class="token punctuation">{</span>width<span class="token punctuation">,</span> items<span class="token punctuation">,</span> flag<span class="token punctuation">,</span> <span class="token constant">H</span><span class="token punctuation">,</span> gap<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span>
        items<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            item<span class="token punctuation">.</span>style<span class="token punctuation">.</span>width <span class="token operator">=</span> width <span class="token operator">+</span> <span class="token string">'px'</span>
            item<span class="token punctuation">.</span>style<span class="token punctuation">.</span>position <span class="token operator">=</span> <span class="token string">'absolute'</span>
            <span class="token keyword">let</span> img <span class="token operator">=</span> item<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span>
            <span class="token comment">/* 图片是否加载完成 */</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>img<span class="token punctuation">.</span>complete<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">/* 获取每一列的最小高度 */</span>
                <span class="token keyword">let</span> tag <span class="token operator">=</span> <span class="token constant">H</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token constant">H</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                item<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> tag <span class="token operator">*</span> <span class="token punctuation">(</span>width <span class="token operator">+</span> gap<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'px'</span>
                item<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token constant">H</span><span class="token punctuation">[</span>tag<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'px'</span>
                img<span class="token punctuation">.</span>style<span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token string">'100%'</span>
                img<span class="token punctuation">.</span>style<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token string">'100%'</span>
                <span class="token constant">H</span><span class="token punctuation">[</span>tag<span class="token punctuation">]</span> <span class="token operator">+=</span> img<span class="token punctuation">.</span>height <span class="token operator">*</span> width <span class="token operator">/</span> img<span class="token punctuation">.</span>width <span class="token operator">+</span> gap
                flag<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                img<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'load'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                    <span class="token keyword">let</span> tag <span class="token operator">=</span> <span class="token constant">H</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token constant">H</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    item<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> tag <span class="token operator">*</span> <span class="token punctuation">(</span>width <span class="token operator">+</span> gap<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'px'</span>
                    item<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token constant">H</span><span class="token punctuation">[</span>tag<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'px'</span>
                    img<span class="token punctuation">.</span>style<span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token string">'100%'</span>
                    img<span class="token punctuation">.</span>style<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token string">'100%'</span>
                    <span class="token constant">H</span><span class="token punctuation">[</span>tag<span class="token punctuation">]</span> <span class="token operator">+=</span> img<span class="token punctuation">.</span>height <span class="token operator">*</span> width <span class="token operator">/</span> img<span class="token punctuation">.</span>width <span class="token operator">+</span> gap
                    flag<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
                    <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

实现原理：
    初始化，计算出列宽来，将<span class="token constant">H</span>作为列高存储器。然后计算子元素，清除父容器内容。
    遍历子元素，设置其都为绝对定位，设置其列宽，然后监听其下的图片是否加载完毕。
    如果加载完毕，那么计算应该所在的位置，瀑布流的核心就是哪一列高度最小就在那一列上设置新的图片。当然他的相对高度和间距也要计算出来，同时在当前的<span class="token constant">H</span>上把高度存起来。
    每次图片加载完就更新虚拟节点到父容器中。

优点：
    控制灵活，随意扩展
    也可以无限加载，不用过多考虑兼容性问题
    同时可以添加诸多动画来增强用户体验

缺点：
    实现相对复杂
    图片填充需要考虑图片加载状态
    性能相对纯css实现较差
</code></pre></div><h5 id="_3-css实现垂直居中-3种"><a href="#_3-css实现垂直居中-3种" class="header-anchor">#</a> 3.css实现垂直居中（3种）</h5> <ol><li>flex</li></ol> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li>absolute + translate -50%</li></ol> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.child</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">,</span> -50%<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="3"><li>absolute + 负 margin</li></ol> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.child</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> -150px<span class="token punctuation">;</span>    <span class="token comment">/* 子元素 width 的一半 */</span>
  <span class="token property">margin-top</span><span class="token punctuation">:</span> -100px<span class="token punctuation">;</span>     <span class="token comment">/* 子元素 height 的一半 */</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="4"><li>absolute + margin: auto</li></ol> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.child</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">right</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">bottom</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="5"><li>table 标签</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>table<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>tr<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>td<span class="token operator">&gt;</span>
            Lorem ipsum dolor sit amet<span class="token punctuation">,</span> consectetur adipisicing elit<span class="token punctuation">.</span> Tempora harum voluptates quae velit eveniet<span class="token punctuation">,</span> accusamus<span class="token punctuation">,</span> quas ratione placeat<span class="token operator">!</span> Nisi perferendis facere<span class="token punctuation">,</span> error sed possimus molestias et<span class="token punctuation">.</span> Quas accusantium<span class="token punctuation">,</span> maiores aliquid<span class="token operator">?</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>td<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>tr<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>table<span class="token operator">&gt;</span>

</code></pre></div><ol start="6"><li>div 模仿 table</li></ol> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.child</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>
  <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="7"><li>高度为 100% 的伪元素 + display: inline-block</li></ol> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.parent</span> <span class="token punctuation">{</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.parent:before,
.parent:after</span> <span class="token punctuation">{</span>
  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>            <span class="token comment">/* 前后伪元素高度 100% */</span>
  <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>  <span class="token comment">/* 伪元素垂直居中 */</span>
<span class="token punctuation">}</span>

<span class="token selector">.child</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>
  <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>  <span class="token comment">/* 子元素在 100% 高度中垂直居中 */</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="js"><a href="#js" class="header-anchor">#</a> JS</h4> <h5 id="_1-分片上传底层原理"><a href="#_1-分片上传底层原理" class="header-anchor">#</a> 1.分片上传底层原理</h5> <p><strong>Blob</strong>对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成 ReadableStream 来用于数据操作。</p> <p>File接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p> <p><strong>Blob.slice()</strong></p> <p>返回一个新的 Blob 对象，包含了源 Blob 对象中指定范围内的数据。和数组的slice方法类似，截取数组的内容，大文件切片就是基于此方法来切分。</p> <h5 id="_2-防抖节流"><a href="#_2-防抖节流" class="header-anchor">#</a> 2.防抖节流</h5> <h5 id="_3-原型和原型链"><a href="#_3-原型和原型链" class="header-anchor">#</a> 3.原型和原型链</h5> <h5 id="_4-事件冒泡和委托原理和应用"><a href="#_4-事件冒泡和委托原理和应用" class="header-anchor">#</a> 4.事件冒泡和委托原理和应用</h5> <h5 id="_5-数组深拷贝的实现方法"><a href="#_5-数组深拷贝的实现方法" class="header-anchor">#</a> 5.数组深拷贝的实现方法</h5> <h5 id="_6-var和let的区别"><a href="#_6-var和let的区别" class="header-anchor">#</a> 6.var和let的区别</h5> <h5 id="_7-原生ajax的过程实现"><a href="#_7-原生ajax的过程实现" class="header-anchor">#</a> 7.原生ajax的过程实现</h5> <ol><li>创建 XMLHttpRequest 对象  var xhr = new XMLHttpRequest()</li> <li>调用open方法，设置请求方式和请求路径url  xhr.open('get', url)</li> <li>调用send方法，发送请求 xhr.send()</li> <li>准备一个函数，用于接受服务器响应的结果</li></ol> <h5 id="_8-eventloop事件轮循"><a href="#_8-eventloop事件轮循" class="header-anchor">#</a> 8.eventloop事件轮循</h5> <p>所有异步任务在执行过程，都是从异步任务队列中将回调函数拿到了任务栈中来执行，此时执行完任务栈里面的代码后，还是会继续按照之前的方式，先从微任务中拿，再从宏任务拿</p> <h5 id="_9-一个字符串-获取每个数字出现的次数"><a href="#_9-一个字符串-获取每个数字出现的次数" class="header-anchor">#</a> 9.一个字符串，获取每个数字出现的次数</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> str<span class="token operator">=</span><span class="token string">&quot;helloworldilikeyou&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">//创建一个对象用于保存每个字符以及他的次数</span>
			 <span class="token comment">//把str中的每个字符当对象的属性名；</span>
			 <span class="token comment">//由于对象的属性名是唯一的，所以就不会存在重复的字符；</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>str<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> key<span class="token operator">=</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  		 <span class="token comment">//遍历字符串，key的值就是str的每个字符</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">==</span><span class="token keyword">undefined</span><span class="token punctuation">)</span>  <span class="token comment">//判断如果新对象中，有没有我们遍历的字符，如果没有，</span>
       obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>           <span class="token comment">//就在对象中添加一个属性和值， 属性名就是遍历的字符串</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                   <span class="token comment">//反之-就是对象中已经有一个这样的字符了，当然他这个时候值就是1</span>
    	obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>          <span class="token comment">//第二次遍历到他的时候就把他原来的值加1，再赋值给他</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  下图就是获取到的每个字符出现的次数
</code></pre></div><h5 id="_10-一个字符串-获取连续出现的字符串"><a href="#_10-一个字符串-获取连续出现的字符串" class="header-anchor">#</a> 10.一个字符串，获取连续出现的字符串</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//首先写一个函数，传入一个字符串</span>
<span class="token keyword">function</span> <span class="token function">getMaxCharacters</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment">//match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。</span>
    <span class="token keyword">var</span> arr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\w)\1+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">)</span>
    <span class="token keyword">var</span> max <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length
    arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=&gt;</span> max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> v<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> maxArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=&gt;</span> v<span class="token punctuation">.</span>length <span class="token operator">===</span> max<span class="token punctuation">)</span>
    maxArr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        map<span class="token punctuation">[</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">.</span>length
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> map
<span class="token punctuation">}</span>

<span class="token function">getMaxCharacters</span><span class="token punctuation">(</span><span class="token string">'abcaakjbb'</span><span class="token punctuation">)</span>  <span class="token comment">// { a: 2, b: 2 }</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">getMaxCharacters</span><span class="token punctuation">(</span><span class="token string">'abcaakjbb'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h5 id="_11-数据的基本类型"><a href="#_11-数据的基本类型" class="header-anchor">#</a> 11.数据的基本类型</h5> <h5 id="_12-判断数据类型的方法"><a href="#_12-判断数据类型的方法" class="header-anchor">#</a> 12.判断数据类型的方法</h5> <h5 id="_13-object-defineproperty和proxy的区别"><a href="#_13-object-defineproperty和proxy的区别" class="header-anchor">#</a> 13.Object.defineProperty和proxy的区别</h5> <h5 id="_14-async-await的用法、原理-await返回的是什么"><a href="#_14-async-await的用法、原理-await返回的是什么" class="header-anchor">#</a> 14.async await的用法、原理，await返回的是什么</h5> <ul><li>await只能在async函数中使用，不然会报错</li> <li>async函数返回的是一个Promise对象，有无值看有无return值</li> <li>await后面最好是接Promise，虽然接其他值也能达到排队效果</li> <li>async/await作用是<strong>用同步方式，执行异步操作</strong></li></ul> <h5 id="_15-promise的用法及原理"><a href="#_15-promise的用法及原理" class="header-anchor">#</a> 15.promise的用法及原理</h5> <p>Promise是一个构造函数，必须接收一个<strong>函数</strong>作为参数，我们称该函数为executor（执行器），executor又包含了两个<strong>函数</strong>作为参数，分别是resolve和reject，当异步操作成功后马上执行resolve，异步操作失败后，会马上执行reject</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyPromise</span><span class="token punctuation">{</span>
     <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> executor <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'MyPromise必须接收一个函数作为参数'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 执行传进来的函数executor</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">executor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

romise中有<span class="token keyword">throw</span>的话，就相当于执行了reject。这就要使用<span class="token keyword">try</span> catch了
为什么要绑定<span class="token keyword">this</span>呢？这是为了resolve和reject的<span class="token keyword">this</span>指向永远指向当前的MyPromise实例，防止随着函数执行环境的改变而改变
</code></pre></div><p>Promise有三种状态，分别是Pending（等待中），Fulfilled（已成功），Rejected（已失败）。</p> <p>状态只能由<code>Pending</code>变成<code>Fulfilled</code>， 或由<code>Pending</code>变成<code>Rejected</code>，且状态确定后不会再发生变化（不能再次修改）。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 定义三种状态常量</span>
<span class="token keyword">const</span> <span class="token constant">PENDING</span> <span class="token operator">=</span> <span class="token string">'pending'</span>
<span class="token keyword">const</span> <span class="token constant">FULFILLED</span> <span class="token operator">=</span> <span class="token string">'fulfilled'</span>
<span class="token keyword">const</span> <span class="token constant">REJECTED</span> <span class="token operator">=</span> <span class="token string">'reject'</span>

<span class="token keyword">class</span> <span class="token class-name">MyPromise</span><span class="token punctuation">{</span>
  status <span class="token operator">=</span> <span class="token constant">PENDING</span>  <span class="token comment">// 设置初始状态</span>
  value <span class="token operator">=</span> <span class="token keyword">undefined</span>  <span class="token comment">// 设置初始值</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> executor <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'MyPromise必须接收一个函数作为参数'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 执行executor</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">executor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">FULFILLED</span>  <span class="token comment">// 修改状态</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> val  <span class="token comment">// 修改值</span>
  <span class="token punctuation">}</span>
  <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token constant">REJECT</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">REJECT</span>   <span class="token comment">// 修改状态</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> err  <span class="token comment">// 修改值</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Promise核心：then方法</p> <ul><li>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是<strong>为 Promise 实例添加状态改变时的回调函数</strong>。</li> <li>then方法<strong>接收两个可选参数</strong><code>onFulfilled</code> 和<code>onRejected</code>，参数必须是函数</li> <li><code>then</code>方法<strong>返回的是一个新的<code>Promise</code>实例</strong>（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</li> <li><strong><code>Promise</code> 实例化时传入的函数会立即执行，<code>then(...)</code> 中的回调需要异步延迟调用。</strong></li></ul> <h5 id="_16-函数的柯里化及作用"><a href="#_16-函数的柯里化及作用" class="header-anchor">#</a> 16.函数的柯里化及作用</h5> <p>主要有3个作用： <strong>参数复用</strong>、<strong>提前返回</strong>和 <strong>延迟执行</strong></p> <p>我们来简单的解释一下: 参数复用：拿上面 <code>f</code>这个函数举例，只要传入一个参数 <code>z</code>，执行，计算结果就是 <code>1 + 2 + z</code> 的结果，1 和 2 这两个参数就直接可以复用了。</p> <p>提前返回 和 延迟执行 也很好理解，因为每次调用函数时，它只接受一部分参数，并返回一个函数（提前返回），直到(延迟执行)传递所有参数为止。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * 将函数柯里化
 * @param fn    待柯里化的原函数
 * @param len   所需的参数个数，默认为原函数的形参个数
 */</span>
<span class="token keyword">function</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>len <span class="token operator">=</span> fn<span class="token punctuation">.</span>length</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">_curry</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>fn<span class="token punctuation">,</span>len<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 中转函数
 * @param fn    待柯里化的原函数
 * @param len   所需的参数个数
 * @param args  已接收的参数列表
 */</span>
<span class="token keyword">function</span> <span class="token function">_curry</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>len<span class="token punctuation">,</span><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> _args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>args<span class="token punctuation">,</span><span class="token operator">...</span>params<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>_args<span class="token punctuation">.</span>length <span class="token operator">&gt;=</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>_args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">_curry</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>fn<span class="token punctuation">,</span>len<span class="token punctuation">,</span><span class="token operator">...</span>_args<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="_17-函数的执行流程"><a href="#_17-函数的执行流程" class="header-anchor">#</a> 17.函数的执行流程</h5> <ol><li>为函数创建一个执行环境</li> <li>复制函数的 [[scopes]] 属性中的对象构建起执行环境的作用链域</li> <li>创建函数活动对象并推入执行环境作用链域的前端</li> <li>执行代码</li> <li>销毁执行环境和活动对象（闭包情况下活动对象仍被引用没被销毁）</li></ol> <h5 id="_18-进程和线程的区别"><a href="#_18-进程和线程的区别" class="header-anchor">#</a> 18.进程和线程的区别</h5> <p>做个简单的比喻：进程=火车，线程=车厢</p> <ul><li>线程在进程下行进（单纯的车厢无法运行）</li> <li>一个进程可以包含多个线程（一辆火车可以有多个车厢）</li> <li>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）</li> <li>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）</li> <li>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</li> <li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）</li> <li>进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）</li> <li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－&quot;互斥锁&quot;</li> <li>进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”</li></ul> <h5 id="_22-try-catch-中可以捕捉错误的类型"><a href="#_22-try-catch-中可以捕捉错误的类型" class="header-anchor">#</a> 22.try catch 中可以捕捉错误的类型</h5> <h5 id="_23-for-of-和for-in的区别"><a href="#_23-for-of-和for-in的区别" class="header-anchor">#</a> 23.for of 和for in的区别</h5> <p>简单来说就是它们两者都可以用于遍历，不过<code>for in</code>遍历的是数组的索引（<code>index</code>），而<code>for of</code>遍历的是数组元素值（<code>value</code>）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// for in</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">a</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">b</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">c</span><span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">}</span>
    
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// a b c</span>

<span class="token comment">//for of</span>
<span class="token keyword">const</span> array1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span>
 
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> val <span class="token keyword">of</span> array1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// a b c</span>
</code></pre></div><h5 id="_24-new一个实例的执行流程"><a href="#_24-new一个实例的执行流程" class="header-anchor">#</a> 24.new一个实例的执行流程</h5> <p>(1) 创建一个新对象；
(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） ；
(3) 执行构造函数中的代码（为这个新对象添加属性） ；
(4) 返回新对象。</p> <h5 id="_25-反转一个链表"><a href="#_25-反转一个链表" class="header-anchor">#</a> 25.反转一个链表</h5> <h5 id="_26-http为什么是三次握手-四次挥手"><a href="#_26-http为什么是三次握手-四次挥手" class="header-anchor">#</a> 26.http为什么是三次握手？四次挥手？</h5> <p>第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p> <p>第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p> <p>第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常</p> <p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中<strong>ACK报文是用来应答的，SYN报文是用来同步的</strong>。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，&quot;你发的FIN报文我收到了&quot;。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p> <h5 id="_27-https是怎么进行加密的"><a href="#_27-https是怎么进行加密的" class="header-anchor">#</a> 27.https是怎么进行加密的？</h5> <p>HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法</p> <ul><li>散列函数 散列函数验证信息的完整性</li> <li>对称加密 对称加密算法采用协商的密钥对数据加密</li> <li>非对称加密 非对称加密实现身份认证和密钥协商</li></ul> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f94b302f31154dc385821ec2c31c1e5b~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png"></p> <h5 id="_28-像素px和物理像素的关系"><a href="#_28-像素px和物理像素的关系" class="header-anchor">#</a> 28.像素px和物理像素的关系</h5> <ul><li><p>物理像素是硬件条件所决定的</p></li> <li><p>逻辑分辨率可以任意设置，大小不受限于物理分辨率</p></li> <li><p>css 样式中的 px 为逻辑像素</p></li> <li><p>单位面积内逻辑像素越多，显示的内容越多</p></li> <li><p>逻辑像素无法和物理像素完全对应的情况下，会可能存在显示问题</p></li> <li><p>与物理像素完全匹配的设计展示最清新，过低太模糊、过高被压缩</p></li></ul> <h5 id="_29-pc端和h5怎么兼容-除了响应式"><a href="#_29-pc端和h5怎么兼容-除了响应式" class="header-anchor">#</a> 29.pc端和H5怎么兼容？除了响应式</h5> <h5 id="_30-es6中箭头函数"><a href="#_30-es6中箭头函数" class="header-anchor">#</a> 30.ES6中箭头函数</h5> <ol><li>箭头函数的this永远指向其父作用域，任何方法都改变不了，包括call，apply，bind。普通函数的this指向调用它的那个对象。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'jike'</span><span class="token punctuation">,</span>
    <span class="token function-variable function">init</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//为body添加一个点击事件，看看这个点击后的this属性有什么不同</span>
        document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//?? this在浏览器默认是调用时的对象,可变的？                  </span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
person<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

上例中，init是<span class="token keyword">function</span>，以person<span class="token punctuation">.</span>init调用，其内部<span class="token keyword">this</span>就是person本身，而onclick回调是箭头函数，
其内部的<span class="token keyword">this</span>，就是父作用域的<span class="token keyword">this</span>，就是person，能得到name。

<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'jike'</span><span class="token punctuation">,</span>
    <span class="token function-variable function">init</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token comment">//为body添加一个点击事件，看看这个点击后的this属性有什么不同</span>
        document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//?? this在浏览器默认是调用时的对象,可变的？                  </span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
person<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

上例中，init为箭头函数，其内部的<span class="token keyword">this</span>为全局window，onclick的<span class="token keyword">this</span>也就是init函数的<span class="token keyword">this</span>，也是window，
得到的<span class="token keyword">this</span><span class="token punctuation">.</span>name就为<span class="token keyword">undefined</span>。
</code></pre></div><ol start="2"><li>箭头函数不能作为构造函数，不能使用new</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//构造函数如下：</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">p</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> p<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//如果用箭头函数作为构造函数，则如下</span>
<span class="token keyword">var</span> <span class="token function-variable function">Person</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">p</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> p<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

由于<span class="token keyword">this</span>必须是对象实例，而箭头函数是没有实例的，此处的<span class="token keyword">this</span>指向别处，不能产生person实例，自相矛盾。
</code></pre></div><ol start="3"><li>箭头函数没有arguments，caller，callee</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>箭头函数本身没有arguments，如果箭头函数在一个<span class="token keyword">function</span>内部，它会将外部函数的arguments拿过来使用。
箭头函数中要想接收不定参数，应该使用rest参数<span class="token operator">...</span>解决。

<span class="token keyword">let</span> <span class="token function-variable function">B</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">b</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token constant">B</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">92</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Uncaught ReferenceError: arguments is not defined</span>

<span class="token keyword">let</span> <span class="token function-variable function">C</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>c</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token constant">C</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">82</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token number">11323</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// [3, 82, 32, 11323]</span>
</code></pre></div><ol start="4"><li>箭头函数通过call和apply调用，不会改变this指向，只会传入参数</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
    <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> n <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">c</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> n <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span>
        <span class="token keyword">let</span> m <span class="token operator">=</span> <span class="token punctuation">{</span>
            <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">20</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">.</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 11</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">.</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 11</span>
</code></pre></div><ol start="5"><li>箭头函数没有原型属性</li> <li>箭头函数不能作为Generator函数，不能使用yield关键字</li> <li>箭头函数返回对象时，要加一个小括号</li></ol> <h4 id="vue"><a href="#vue" class="header-anchor">#</a> VUE</h4> <h5 id="_1-spa首屏加载慢怎么解决"><a href="#_1-spa首屏加载慢怎么解决" class="header-anchor">#</a> 1.SPA首屏加载慢怎么解决</h5> <ol><li><p>减少入口文件体积：常用的手段是路由懒加载，把不同的路由对应的组件分割成不同的代码块，待路由被请求的时候单独打包路由，使入口文件变小。</p></li> <li><p>静态资源本地缓存：后端返回资源问题：采用HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头。采用Service Worker离线缓存。前端合理利用localStorage。</p></li> <li><p>UI框架在引用时按需加载，开发过程中可能不止用到一个组件库，全局引入很不推荐！</p></li> <li><p>避免组件重复打包：在webpack的config文件中，修改CommonsChunkPlugin的配置，设置minChunks为2表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件</p></li> <li><p>压缩图片资源，应用自身常用图标，logo等可以放在assets,其余图片可以放在静态托管目录public里面。</p></li> <li><p>使用SSR（服务端渲染），即组件和页面通过服务器生成html字符串，再发送到浏览器。vue可以使用Nuxt.js实现服务端渲染。</p></li></ol> <h5 id="_2-key的作用及什么时候用index-什么是用id"><a href="#_2-key的作用及什么时候用index-什么是用id" class="header-anchor">#</a> 2.key的作用及什么时候用index,什么是用id</h5> <h5 id="_3-data为什么是函数"><a href="#_3-data为什么是函数" class="header-anchor">#</a> 3.data为什么是函数</h5> <ul><li>因为组件是用来复用的，且 JS 里对象是引用关系，</li> <li>如果组件中 data 是一个对象，那么这样作用域没有隔离，</li> <li>子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，</li> <li>那么每个实例可以维护一份被返回对象的独立的拷贝，</li> <li>组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，</li> <li>是不会被复用的，因此不存在引用对象的问题。</li></ul> <h5 id="_4-diff算法"><a href="#_4-diff算法" class="header-anchor">#</a> 4.diff算法</h5> <p>在js中,渲染真实<code>DOM</code>的开销是非常大的, 比如我们修改了某个数据,如果直接渲染到真实<code>DOM</code>, 会引起整个<code>dom</code>树的重绘和重排。那么有没有可能实现只更新我们修改的那一小块dom而不要更新整个<code>dom</code>呢？此时我们就需要先根据真实<code>dom</code>生成虚拟<code>dom</code>， 当虚拟<code>dom</code>某个节点的数据改变后会生成有一个新的<code>Vnode</code>, 然后新的<code>Vnode</code>和旧的<code>Vnode</code>作比较，发现有不一样的地方就直接修改在真实DOM上，然后使旧的<code>Vnode</code>的值为新的<code>Vnode</code>。</p> <p><strong>diff</strong>的过程就是调用<code>patch</code>函数，比较新旧节点，一边比较一边给真实的<code>DOM</code>打补丁。在采取<code>diff</code>算法比较新旧节点的时候，比较只会在同层级进行。 在<code>patch</code>方法中，首先进行树级别的比较 <code>new Vnode</code>不存在就删除 <code>old Vnode</code> <code>old Vnode</code> 不存在就增加新的<code>Vnode</code> 都存在就执行diff更新 当确定需要执行diff算法时，比较两个<code>Vnode</code>，包括三种类型操作：属性更新，文本更新，子节点更新 新老节点均有子节点，则对子节点进行<code>diff</code>操作，调用<code>updatechidren</code> 如果老节点没有子节点而新节点有子节点，先清空老节点的文本内容，然后为其新增子节点 如果新节点没有子节点，而老节点有子节点的时候，则移除该节点的所有子节点 老新老节点都没有子节点的时候，进行文本的替换</p> <p><strong>updateChildren</strong> 将<code>Vnode</code>的子节点Vch和oldVnode的子节点oldCh提取出来。 <code>oldCh和vCh</code>各有两个头尾的变量<code>StartIdx和EndIdx</code>，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了<code>key</code>，就会用<code>key</code>进行比较，在比较的过程中，变量会往中间靠，一旦<code>StartIdx&gt;EndIdx</code>表明<code>oldCh和vCh</code>至少有一个已经遍历完了，就会结束比较。</p> <h5 id="_5-数据双向绑定的原理"><a href="#_5-数据双向绑定的原理" class="header-anchor">#</a> 5.数据双向绑定的原理</h5> <p>当一个<strong>Vue</strong>实例创建时，Vue会遍历data选项的属性，用 <strong>Object.defineProperty</strong> 将它们转为 getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。</p> <p>每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher重新计算，从而致使它关联的组件得以更新。</p> <h5 id="_6-强制更新视图的方法-2种以上"><a href="#_6-强制更新视图的方法-2种以上" class="header-anchor">#</a> 6.强制更新视图的方法（2种以上）</h5> <ol><li>this.$forceUpdate()</li> <li>this.$set('ssa', aaa)</li></ol> <h5 id="_8-vue3中setup-语法糖"><a href="#_8-vue3中setup-语法糖" class="header-anchor">#</a> 8.vue3中setup 语法糖</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>script setup<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><ol><li><p>组件自动注册</p> <p>在 script setup 中，引入的组件可以直接使用，无需再通过<code>components</code>进行注册，并且无法指定当前组件的名字，它会自动以文件名为主，也就是不用再写<code>name</code>属性了。</p></li> <li><p>使用 props</p></li></ol> <p>​	通过<code>defineProps</code>指定当前 props 类型，获得上下文的props对象。</p> <ol start="3"><li>使用 emits</li></ol> <p>​	使用<code>defineEmit</code>定义当前组件含有的事件，并通过返回的上下文去执行 emit。</p> <ol start="4"><li>获取 slots 和 attrs</li></ol> <p>​	可以通过<code>useContext</code>从上下文中获取 slots 和 attrs。不过提案在正式通过后，废除了这个语法，被拆分成了<code>useAttrs</code>和<code>useSlots</code>。</p> <h5 id="_9-vue3的钩子函数"><a href="#_9-vue3的钩子函数" class="header-anchor">#</a> 9.vue3的钩子函数</h5> <h5 id="_10-vuex和paina的区别"><a href="#_10-vuex和paina的区别" class="header-anchor">#</a> 10.vuex和paina的区别</h5> <p>Vuex的优点</p> <ul><li>支持调试功能，如时间旅行和编辑</li> <li>适用于大型、高复杂度的Vue.js项目</li></ul> <p>Vuex的缺点</p> <ul><li>从 Vue 3 开始，getter 的结果不会像计算属性那样缓存</li> <li>Vuex 4有一些与类型安全相关的问题</li></ul> <p>Pinia的优点</p> <ul><li>完整的 TypeScript 支持：与在 Vuex 中添加 TypeScript 相比，添加 TypeScript 更容易</li> <li>极其轻巧（体积约 1KB）</li> <li>store 的 action 被调度为常规的函数调用，而不是使用 <code>dispatch</code> 方法或 <code>MapAction</code> 辅助函数，这在 Vuex 中很常见</li> <li>支持多个Store</li> <li>支持 Vue devtools、SSR 和 webpack 代码拆分</li></ul> <p>Pinia的缺点</p> <ul><li>不支持时间旅行和编辑等调试功能</li></ul> <h5 id="_11-vuex的构成及属性"><a href="#_11-vuex的构成及属性" class="header-anchor">#</a> 11.vuex的构成及属性</h5> <h5 id="_12-nexttick的原理"><a href="#_12-nexttick的原理" class="header-anchor">#</a> 12.$nextTick的原理</h5> <ol><li><code>nextTick</code>是<code>Vue</code>提供的一个全局<code>API</code>,是在下次<code>DOM</code>更新循环结束之后执行延迟回调，在修改数据之后使用<code>$nextTick</code>，则可以在回调中获取更新后的<code>DOM</code>；</li> <li>Vue在更新DOM时是异步执行的。只要侦听到数据变化，<code>Vue</code>将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个<code>watcher</code>被多次触发，只会被推入到队列中-次。这种在缓冲时去除重复数据对于避免不必要的计算和<code>DOM</code>操作是非常重要的。<code>nextTick</code>方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用；</li> <li>比如，我在干什么的时候就会使用nextTick，传一个回调函数进去，在里面执行dom操作即可；</li> <li>我也有简单了解<code>nextTick</code>实现，它会在<code>callbacks</code>里面加入我们传入的函数，然后用<code>timerFunc</code>异步方式调用它们，首选的异步方式会是<code>Promise</code>。这让我明白了为什么可以在<code>nextTick</code>中看到<code>dom</code>操作结果。</li></ol> <h5 id="_13-computed是计算用的-有缓冲-请问为什么有缓冲"><a href="#_13-computed是计算用的-有缓冲-请问为什么有缓冲" class="header-anchor">#</a> 13.computed是计算用的，有缓冲，请问为什么有缓冲？</h5> <ol><li><p>Computed也是响应式的</p> <p>Computed是响应式的，读取Computed会触发get，设置Computed会触发set</p></li> <li><p>Computed如何控制缓存</p></li></ol> <p>​	计算属性是有缓存的，比如某个计算属性C，它依赖data中的A，如果没有缓存的话，每次读取C时，C都回去读取A，从而触发A的get。多次触发A的get有时候是一个非常消耗性能的操	作，所以Computed必须要有缓存</p> <p>​	computed里面控制缓存最重要的一点就是脏数据标记为dirty, dirty是watcher的一个属性。</p> <p>​	当dirty为true时，读取computed会重新计算
​	当dirty为false时，读取computed会使用缓存</p> <ol start="3"><li>依赖的data发生变化，computed是如何更新的</li></ol> <p>​	页面P依赖计算属性C, 计算属性C又依赖data里面的A, computed更新步骤如下:</p> <p>​		由于C依赖了A, A可以收集到C的watcher</p> <p>​		当A发生变化时，会将watcher的脏数据标记位dirty设置为true</p> <p>​		并且A会收集到页面P的watcher，A通知P进行更新，从而页面P重新读取计算属性C, 由于此时dirty为true，此时的计算属性会重新计算。</p> <p>​		computed更新完毕，重新将脏数据标记位dirty设置为false，如果其依赖的A不发生改变，那下次再进入就会读取缓存。</p> <ol start="4"><li>计算属性C是如何让data中的A收集到页面P的watcher的
这其实是计算属性中一个非常巧妙的操作。来看一下核心的源码(已简化)</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createComputedGetter</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token comment">// 获取到相应 key 的 computed-watcher</span>
        <span class="token keyword">var</span> watcher <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_computedWatchers<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果 computed 依赖的数据变化，dirty 会变成true，</span>
        <span class="token comment">// 从而重新计算，然后更新缓存值 watcher.value</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>watcher<span class="token punctuation">.</span>dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            watcher<span class="token punctuation">.</span><span class="token function">evaluate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>        
        <span class="token comment">// 这里是 月老computed 牵线的重点，让双方建立关系</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            watcher<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>        
        <span class="token keyword">return</span> watcher<span class="token punctuation">.</span>value
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="_14-vuex中mutation为什么只能是同步的-可以不可以改成异步的-如果可以-为什么还要设计一个action-如何实现的"><a href="#_14-vuex中mutation为什么只能是同步的-可以不可以改成异步的-如果可以-为什么还要设计一个action-如何实现的" class="header-anchor">#</a> 14.vuex中mutation为什么只能是同步的？可以不可以改成异步的？如果可以，为什么还要设计一个action?如何实现的？</h5> <ul><li>Mutation中是同步函数和Action中是异步函数，属于一种约定，为了更好的追踪vuex的状态变化，希望我们都按照这种原则进行开发</li> <li>Mutation必须是同步函数</li> <li>更改state的唯一方法是通过提交 mutation</li> <li>Action中不进行状态的直接更改，而是通过commit触发mutation</li> <li>mutation的触发通过store.commit来进行</li> <li>action的触发通过store.dispatch进行</li> <li>mutations里的同步意义在于，每个mutation执行完毕之后，可以得到对应的状态，使用devtools可以跟踪状态的变化</li></ul> <h5 id="_15-vue如何优化seo"><a href="#_15-vue如何优化seo" class="header-anchor">#</a> 15.vue如何优化SEO?</h5> <ol><li>SSR服务端渲染</li> <li>Nuxt静态化</li> <li>预渲染 prerender-spa-plugin</li> <li>使用Phantomjs针对爬虫做处理</li></ol> <h5 id="_16-watch不能深度监听-需要设置deep-这个是怎么实现的"><a href="#_16-watch不能深度监听-需要设置deep-这个是怎么实现的" class="header-anchor">#</a> 16.watch不能深度监听，需要设置deep，这个是怎么实现的？</h5> <ol><li>监听数据改变时， watch是如何工作的？</li></ol> <p>​	Vue会把数据设置响应式，即设置他的 get 和 set 当数据被读取，get被触发，然后收集到读取他的东西，保存到依赖收集器 当数据被改变，set被触发，然后通知曾经读取他的东西	进行更新。
​    watch 在一开始初始化的时候，会 读取 一遍 监听的数据的值，于是，此时 那个数据就收集到 watch 的 watcher 了 然后 你给 watch 设置的 handler ，watch 会放入  	watcher 的更新函数中 当 数据改变时，通知  watch 的 watcher 进行更新，于是 你设置的 handler 就被调用了.</p> <ol start="2"><li>设置了immediate ， watch是如何工作的？</li></ol> <p>​	设置了 immediate 时，就不需要在数据改变的时候才会触发。 而是在 初始化 watch 时，在读取了 监听的数据的值 之后，便立即调用一遍你设置的监听回调，然后传入刚读取的值.</p> <ol start="3"><li>设置了deep ， watch是如何工作的？</li></ol> <p>​	从vue源码可以看到， 当存在deep属性时，会执行traverse方法。 简单来讲，就是递归收集对象或数组的子属性值。</p> <h4 id="webpack"><a href="#webpack" class="header-anchor">#</a> WEBPACK</h4> <h5 id="_1-webpack执行流程"><a href="#_1-webpack执行流程" class="header-anchor">#</a> 1.webpack执行流程</h5> <p><code>初始化参数：</code>  从配置文件和shell 语句中读取与合并参数，得到最终的参数。</p> <p><code>开始编译：</code>  用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行 compiler 对象的 run 方法开始执行编译。</p> <p><code>确定入口：</code> 根据配置中的 entry 找出所有的入口文件。</p> <p><code>编译模块：</code> 从入口文件出发，调用所有配置的 Loader 对模块进行编译，找出该模块依赖的模块，再递归本步骤直到所有依赖文件都经过本步骤的处理。</p> <p>完成模块编译： 在经过第 4 步使用 Loader 编译完所有模块之后，得到每个模块被编译后的最终内容以及它们之间的依赖关系。</p> <p><code>输出资源：</code> 根据入口和模块之间的关系，组装成一个个包含多个模块的 chunk，再把每个 chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会。</p> <p><code>输出完成：</code> 在确定输出内容之后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</p> <h5 id="_2-loaders和plugins的区别、实现原理"><a href="#_2-loaders和plugins的区别、实现原理" class="header-anchor">#</a> 2.loaders和plugins的区别、实现原理</h5> <p><code>Loader</code> 本质就是一个函数，在该函数对接收到的内容进行转换，返回转换后的结果。因为 webpack 只认识 js，所以，你也可以将 Loader 称之为“翻译官”，对其他类型的资源进行转译的预处理工作。</p> <p><code>Plugin</code> 直译为插件，基于事件流框架 <code>Tapable</code>。Plugin 可以扩展 webpack 的功能，让 webpack 具有更多的灵活性。在 Webpack 运行的生命周期中会广播出许多事件，Plugin可以监听这些事件，在合适的时机通过 webpack 提供的 API 改变输出结果。</p> <h5 id="_3-loaders的执行顺序"><a href="#_3-loaders的执行顺序" class="header-anchor">#</a> 3.loaders的执行顺序</h5> <p>从右向左</p> <h5 id="_4-webpack怎么优化代码"><a href="#_4-webpack怎么优化代码" class="header-anchor">#</a> 4.webpack怎么优化代码</h5> <ol><li>JS 压缩</li> <li>CSS 压缩</li> <li>代码分离</li></ol> <p>​	代码分离能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，可以缩短页面加载时间。</p> <ol start="4"><li>抽离重复代码</li></ol> <h5 id="_5-rollup和webpack的区别-有什么优势"><a href="#_5-rollup和webpack的区别-有什么优势" class="header-anchor">#</a> 5.rollup和webpack的区别，有什么优势</h5> <p>Webpack:</p> <ol><li><strong>代码分割</strong>可以将你的 app 分割成许多个容易管理的分块，这些分块能够在用户使用你的 app 时按需加载。这意味着你的用户可以有更快的交互体验。因为访问那些没有使用代码分割的应用时，必须要等待整个应用都被下载并解析完成。当然，你<strong>也可以</strong>自己手动去进行代码分割，但是……总之，祝你好运。</li> <li><strong>静态资源</strong>的导入：图片、CSS 等静态资源可以直接导入到你的 app 中，就和其它的模块、节点一样能够进行依赖管理。因此，我们再也不用小心翼翼地将各个静态文件放在特定的文件夹中，然后再去用脚本给文件 URL 加上哈希串了。Webpack 已经帮你完成了这一切。</li></ol> <p>Rollup:</p> <ol><li>它利用 ES2015 模块的巧妙设计，尽可能高效地构建精简且易分发的 JavaScript 库。而其它的模块打包器（包括 Webpack在内）都是通过将模块分别封装进函数中，然将这些函数通过能在浏览器中实现的 <code>require</code> 方法打包，最后依次处理这些函数。在你需要实现按需加载的时候，这种做法非常的方便，但是这样做引入了很多无关代码，比较浪费资源。当<a href="https://link.juejin.cn?target=https%3A%2F%2Fnolanlawson.com%2F2016%2F08%2F15%2Fthe-cost-of-small-modules%2F" target="_blank" rel="noopener noreferrer">你有很多模块要打包的时候，这种情况会变得更糟糕<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</li> <li>代码分割是一个很棘手的问题，而 Rollup 并不能做到这一点。同样的，Rollup 也不支持模块热替换（HMR）。而且对于打算使用 Rollup 的人来说，还有一个最大的痛点：它通过<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Frollup%2Frollup-plugin-commonjs" target="_blank" rel="noopener noreferrer">插件<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>处理大多数 CommonJS 文件的时候，一些代码将无法被翻译为 ES2015。</li></ol> <h4 id="git"><a href="#git" class="header-anchor">#</a> GIT</h4> <h5 id="_1-git相关命令"><a href="#_1-git相关命令" class="header-anchor">#</a> 1.git相关命令</h5> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment">#git提交命令</span>
<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span> - 添加文件到暂存区。
<span class="token function">git</span> commit - 将暂存区内容添加到仓库中。


<span class="token function">git</span> commit -m <span class="token punctuation">[</span>message<span class="token punctuation">]</span>
$ <span class="token function">git</span> commit -a


<span class="token function">git</span> <span class="token function">add</span> -A  提交所有变化

<span class="token function">git</span> <span class="token function">add</span> -u  提交被修改<span class="token punctuation">(</span>modified<span class="token punctuation">)</span>和被删除<span class="token punctuation">(</span>deleted<span class="token punctuation">)</span>文件，不包括新文件<span class="token punctuation">(</span>new<span class="token punctuation">)</span>

<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>  提交新文件<span class="token punctuation">(</span>new<span class="token punctuation">)</span>和被修改<span class="token punctuation">(</span>modified<span class="token punctuation">)</span>文件，不包括被删除<span class="token punctuation">(</span>deleted<span class="token punctuation">)</span>文件

<span class="token comment">#使用 git checkout –orphan new_branch ,基于当前分支创建一个独立的分支new_branch；</span>
<span class="token function">git</span> checkout --orphan new_branch
<span class="token comment">#添加所有文件变化至暂存空间</span>
<span class="token function">git</span> <span class="token function">add</span> -A
<span class="token comment">#提交并添加提交记录</span>
<span class="token function">git</span> commit -am <span class="token string">&quot;commit clear&quot;</span>
<span class="token comment">#删除当前分支</span>
<span class="token function">git</span> branch -D master
<span class="token comment">#重新命名当前独立分支为 master</span>
<span class="token function">git</span> branch -m master
<span class="token comment">#推送到远端分支(-f 是 –force 的缩写, 可能会造成代码被覆盖)</span>
<span class="token function">git</span> push -f origin master

<span class="token function">git</span> pull
在目录下执行以下语句后，删除目录重新克隆以下就只有最新版本了。

</code></pre></div><h5 id="_2-git怎么合并单个文件"><a href="#_2-git怎么合并单个文件" class="header-anchor">#</a> 2.git怎么合并单个文件</h5> <p>分支A_bracn和B_branch，只想将A_branch分支的某个文件f.txt合并到B_branch分支上。
git checkout A_branch</p> <p>git checkout --patch B_branch f.txt</p> <p>第一个命令： 切换到A分支；</p> <p>第二个命令：合并B分支上f文件到A分支上，将B分支上 f 文件追加补丁到A分支上 f文件。你可以接受或者拒绝补丁内容。</p> <p>如果只是简单的将A_branch分支的文件f.txt copy到B_branch分支上；<br>
git checkout B_branch
cd path/to/f.txt
git checkout A_bracn f.txt</p> <h4 id="uni-app"><a href="#uni-app" class="header-anchor">#</a> UNI-APP</h4> <h5 id="_1-uni-app的钩子函数"><a href="#_1-uni-app的钩子函数" class="header-anchor">#</a> 1.uni-app的钩子函数</h5> <ol><li><a href="https://uniapp.dcloud.io/collocation/frame/lifetime?id=%E5%BA%94%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" target="_blank" rel="noopener noreferrer">应用生命周期<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <table><thead><tr><th>函数名</th> <th>说明</th></tr></thead> <tbody><tr><td>onLaunch</td> <td>当<code>uni-app</code> 初始化完成时触发（全局只触发一次）</td></tr> <tr><td>onShow</td> <td>当 <code>uni-app</code> 启动，或从后台进入前台显示</td></tr> <tr><td>onHide</td> <td>当 <code>uni-app</code> 从前台进入后台</td></tr> <tr><td>onUniNViewMessage</td> <td>对 <code>nvue</code> 页面发送的数据进行监听，可参考 <a href="https://uniapp.dcloud.io/use-weex?id=nvue-%E5%90%91-vue-%E9%80%9A%E8%AE%AF" target="_blank" rel="noopener noreferrer">nvue 向 vue 通讯<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></td></tr></tbody></table> <ol start="2"><li><a href="https://uniapp.dcloud.io/collocation/frame/lifetime?id=%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" target="_blank" rel="noopener noreferrer">页面生命周期<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <table><thead><tr><th>函数名</th> <th>说明</th> <th>平台差异说明</th> <th>最低版本</th></tr></thead> <tbody><tr><td>onLoad</td> <td>监听页面加载，其参数为上个页面传递的数据，参数类型为Object（用于页面传参），参考<a href="https://uniapp.dcloud.io/api/router?id=navigateto" target="_blank" rel="noopener noreferrer">示例<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></td> <td></td> <td></td></tr> <tr><td>onShow</td> <td>监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面</td> <td></td> <td></td></tr> <tr><td>onReady</td> <td>监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发</td> <td></td> <td></td></tr> <tr><td>onHide</td> <td>监听页面隐藏</td> <td></td> <td></td></tr> <tr><td>onUnload</td> <td>监听页面卸载</td> <td></td> <td></td></tr> <tr><td>onResize</td> <td>监听窗口尺寸变化</td> <td>5+App、微信小程序</td> <td></td></tr> <tr><td>onPullDownRefresh</td> <td>监听用户下拉动作，一般用于下拉刷新，参考<a href="https://uniapp.dcloud.io/api/ui/pulldown" target="_blank" rel="noopener noreferrer">示例<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></td> <td></td> <td></td></tr> <tr><td>onReachBottom</td> <td>页面滚动到底部的事件（不是scroll-view滚到底），常用于下拉下一页数据。具体见下方注意事项</td> <td></td> <td></td></tr> <tr><td>onTabItemTap</td> <td>点击 tab 时触发，参数为Object，具体见下方注意事项</td> <td>微信小程序、百度小程序、H5、5+App（自定义组件模式）</td> <td></td></tr> <tr><td>onShareAppMessage</td> <td>用户点击右上角分享</td> <td>微信小程序、百度小程序、头条小程序、支付宝小程序</td> <td></td></tr> <tr><td>onPageScroll</td> <td>监听页面滚动，参数为Object</td> <td></td> <td></td></tr> <tr><td>onNavigationBarButtonTap</td> <td>监听原生标题栏按钮点击事件，参数为Object</td> <td>5+ App、H5</td> <td></td></tr> <tr><td>onBackPress</td> <td>监听页面返回，返回 event = {from:backbutton、 navigateBack} ，backbutton 表示来源是左上角返回按钮或 android 返回键；navigateBack表示来源是 uni.navigateBack ；详细说明及使用：<a href="http://ask.dcloud.net.cn/article/35120" target="_blank" rel="noopener noreferrer">onBackPress 详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></td> <td>5+App、H5</td> <td></td></tr> <tr><td>onNavigationBarSearchInputChanged</td> <td>监听原生标题栏搜索输入框输入内容变化事件</td> <td>5+App、H5</td> <td>1.6.0</td></tr> <tr><td>onNavigationBarSearchInputConfirmed</td> <td>监听原生标题栏搜索输入框搜索事件，用户点击软键盘上的“搜索”按钮时触发。</td> <td>5+App、H5</td> <td>1.6.0</td></tr> <tr><td>onNavigationBarSearchInputClicked</td> <td>监听原生标题栏搜索输入框点击事件</td> <td>5+App、H5</td> <td>1.6.0</td></tr></tbody></table> <h4 id="自动化测试"><a href="#自动化测试" class="header-anchor">#</a> 自动化测试</h4> <h5 id="_1-说说单元测试"><a href="#_1-说说单元测试" class="header-anchor">#</a> 1.说说单元测试</h5></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vue-press-md/面试经典题型/1_面试经典题型.html" class="prev">
        闭包、作用域等
      </a></span> <span class="next"><a href="/vue-press-md/前端单元测试/1_前端单元测试.html">
        前端单元测试
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vue-press-md/assets/js/app.4de37d2a.js" defer></script><script src="/vue-press-md/assets/js/2.ab91b6d3.js" defer></script><script src="/vue-press-md/assets/js/41.50d2e677.js" defer></script>
  </body>
</html>
