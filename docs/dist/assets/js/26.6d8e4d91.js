(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{424:function(t,a,s){"use strict";s.r(a);var e=s(56),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"补充"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#补充"}},[t._v("#")]),t._v(" 补充")]),t._v(" "),s("h4",{attrs:{id:"es6里的symbol"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6里的symbol"}},[t._v("#")]),t._v(" ES6里的symbol")]),t._v(" "),s("p",[t._v("它的功能类似于一种标识唯一性的ID，每个"),s("code",[t._v("Symbol")]),t._v("实例都是唯一的。 "),s("code",[t._v("Symbol")]),t._v("类型的key是不能通过"),s("code",[t._v("Object.keys()")]),t._v("或者"),s("code",[t._v("for...in")]),t._v("来枚举的， 它未被包含在对象自身的属性名集合("),s("code",[t._v("property names")]),t._v(")之中。 所以，利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义。")]),t._v(" "),s("p",[t._v("// 使用"),s("code",[t._v("Object的API")]),t._v(" "),s("code",[t._v("Object.getOwnPropertySymbols(obj)")]),t._v(" // [Symbol(name)]")]),t._v(" "),s("p",[t._v("// 使用新增的反射API "),s("code",[t._v("Reflect.ownKeys(obj)")]),t._v("// [Symbol(name), 'age', 'title']")]),t._v(" "),s("h4",{attrs:{id:"es6里的set和map"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6里的set和map"}},[t._v("#")]),t._v(" ES6里的set和map")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("Map")]),t._v("对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。构造函数Map可以接受一个数组作为参数。")]),t._v(" "),s("li",[s("code",[t._v("Set")]),t._v("对象允许你存储任何类型的值，无论是原始值或者是对象引用。它类似于数组，但是成员的值都是唯一的，没有重复的值。")])]),t._v(" "),s("h4",{attrs:{id:"vue的key"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue的key"}},[t._v("#")]),t._v(" vue的key")]),t._v(" "),s("ol",[s("li",[s("code",[t._v("key")]),t._v("的作用主要是为了高效的更新虚拟"),s("code",[t._v("DOM")]),t._v(",其原理是"),s("code",[t._v("vue")]),t._v("在"),s("code",[t._v("patch")]),t._v("过程中通过"),s("code",[t._v("key")]),t._v("可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个"),s("code",[t._v("patch")]),t._v("过程更加高效，减少"),s("code",[t._v("DOM")]),t._v("操作量,提高性能。")]),t._v(" "),s("li",[t._v("另外,若不设置"),s("code",[t._v("key")]),t._v("还可能在列表更新时引发一些隐蔽的bug")]),t._v(" "),s("li",[s("code",[t._v("vue")]),t._v("中在使用相同标签名元素的过渡切换时,也会使用到key属性,其目的也是为了让vue可以区分它们， 否则"),s("code",[t._v("vue")]),t._v("只会替换其内部属性而不会触发过渡效果。")])]),t._v(" "),s("h4",{attrs:{id:"普通函数和箭头函数的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#普通函数和箭头函数的区别"}},[t._v("#")]),t._v(" 普通函数和箭头函数的区别")]),t._v(" "),s("ol",[s("li",[t._v("箭头函数是匿名函数，不能作为构造函数，不能使用new")]),t._v(" "),s("li",[t._v("箭头函数不绑定"),s("code",[t._v("arguments")]),t._v("，取而代之用"),s("code",[t._v("rest")]),t._v("参数...解决")]),t._v(" "),s("li",[t._v("箭头函数不绑定"),s("code",[t._v("this")]),t._v("，会捕获其所在的上下文的this值，作为自己的this值")]),t._v(" "),s("li",[t._v("箭头函数通过 "),s("code",[t._v("call() 或 apply()")]),t._v(" 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。")]),t._v(" "),s("li",[t._v("箭头函数没有原型属性")]),t._v(" "),s("li",[t._v("箭头函数不能当做"),s("code",[t._v("Generator")]),t._v("函数,不能使用"),s("code",[t._v("yield")]),t._v("关键字")])]),t._v(" "),s("p",[s("strong",[t._v("总结：")])]),t._v(" "),s("ul",[s("li",[t._v("箭头函数的 "),s("code",[t._v("this")]),t._v("永远指向其上下文的 "),s("code",[t._v("this")]),t._v(" ，任何方法都改变不了其指向，如"),s("code",[t._v("call() , bind() , apply()")])]),t._v(" "),s("li",[t._v("普通函数的this指向调用它的那个对象")])]),t._v(" "),s("h4",{attrs:{id:"js函数柯里化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js函数柯里化"}},[t._v("#")]),t._v(" JS函数柯里化")]),t._v(" "),s("ol",[s("li",[t._v("参数复用")]),t._v(" "),s("li",[t._v("提前确认")]),t._v(" "),s("li",[t._v("延迟运行")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 普通的add函数")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" y\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Currying后")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("curryingAdd")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("x")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("y")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" y\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("           "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 3")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("curryingAdd")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 3")]),t._v("\n\n")])])]),s("h4",{attrs:{id:"实现继承口述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实现继承口述"}},[t._v("#")]),t._v(" 实现继承口述")]),t._v(" "),s("p",[s("strong",[t._v("原型链继承")]),t._v(" 写个父类、子类 子类的原型为父类的实例 子类.prootype = new 父类 修正子类原型为子类本身 子类.prototype.constructor=子类 new 子类即可调用父类方法 构造函数继承 写个父类、子类 在子类中父类.call(this) 即可实现")]),t._v(" "),s("h4",{attrs:{id:"mapstate-mapgetters-mapactions-mapmutations"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mapstate-mapgetters-mapactions-mapmutations"}},[t._v("#")]),t._v(" mapState, mapGetters, mapActions, mapMutations")]),t._v(" "),s("p",[t._v("当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性 mapMutations 其实跟mapState 的作用是类似的，将组件中的 methods 映射为 store.commit 调用")]),t._v(" "),s("h4",{attrs:{id:"osi7层模型-tcp5层模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#osi7层模型-tcp5层模型"}},[t._v("#")]),t._v(" osi7层模型，tcp5层模型")]),t._v(" "),s("p",[t._v("osi7层模型："),s("code",[t._v("物理层-数据链路层-传输层-网络层-应用层-会话层-表示层")])]),t._v(" "),s("p",[t._v("tcp5层模型："),s("code",[t._v("物理层-数据链路层-传输层-网络层-应用层")])]),t._v(" "),s("h4",{attrs:{id:""}},[s("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])])])}),[],!1,null,null,null);a.default=n.exports}}]);