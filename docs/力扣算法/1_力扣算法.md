### 力扣算法

#### [两数之和](https://leetcode-cn.com/problems/two-sum/)

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    let map = {}
    for(let i = 0; i<nums.length; i++) {
        let res = target - nums[i]
        if(map[res] !== undefined) {
            return [map[res], i]
        }
        map[nums[i]] = i
    }
};
```

#### [两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.

```js
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
  let head= null
  let tail = null
  let carry = 0
  while(l1 || l2) {
    const n1 = l1? l1.val : 0;
    const n2 = l2 ? l2.val: 0;
    const sum = n1 + n2 + carry;
    if(!head) {
      head = tail = new ListNode(sum % 10)
    }else{
      tail.next = new ListNode(sum % 10)
      tail = tail.next
    }
    carry = Math.floor(sum / 10)
    if(l1) {
      l1 = l1.next
    }
    if(l2) {
      l2 = l2.next
    }
    
  }
  if(carry > 0) tail.next = new ListNode(carry)
  return head
};
```

#### [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
  // 定义无重复数据数组
  const occ = new Set();
  const len = s.length;
  // rk 为右指针
  let rk = -1; let ans = 0;
  for(let i =0 ; i<len;i++) {
    if(i !=0) {
      occ.delete(s.charAt(i-1))
    }
    while(rk+1 < len && !occ.has(s.charAt(rk+1))) {
      occ.add(s.charAt(rk+1))
      rk++
    }
    ans = Math.max(ans, rk-i+1)
  }
  return ans
};
```

#### [回文数](https://leetcode-cn.com/problems/palindrome-number/)

输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

```js
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
  if(x < 0 || x % 10 ==0 && x!==0 ) return false
  let reverNumber =0;
  while(x > reverNumber) {
    reverNumber = x % 10 + reverNumber * 10
    x = Math.floor(x / 10);
  }

  return x === reverNumber || x === Math.floor(reverNumber / 10)
};
```

#### [有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

输入：s = "()[]{}"
输出：true

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
  const stack = [];
  var map = {
    "{":"}",
    "(":")",
    "[":"]"
  }
  for(const x of s) {
    if(x in map) {
      stack.push(x);
      continue
    }
    if(x !== map[stack.pop()]) return false
  }
  return !stack.length
};
```

#### [合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]

```js
/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
    if (l1 === null) {
        return l2;
    } else if (l2 === null) {
        return l1;
    } else if (l1.val < l2.val) {
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    } else {
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    }
};
```

#### [最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

解法1： 贪心算法：若当前指针所指元素之前的和小于0，则丢弃当前元素之前的数列

解法2： 动态规划：若前一个元素大于0，则将其加到当前元素上

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
  let pre = 0, maxA = nums[0];
  nums.forEach(x => {
    pre = Math.max(pre + x, x);
    maxA = Math.max(maxA, pre);
  });
  return maxA;
};
```

#### [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。

1. 1 阶 + 1 阶
2. 2 阶

```js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
  let p = 0, q = 0, r = 1;
  for (let i = 1; i <= n; ++i) {
      p = q;
      q = r;
      r = p + q;
  }
  return r;
};
```

#### [二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

二叉树的中序遍历：按照访问左子树——根节点——右子树的方式遍历这棵树，而在访问左子树或者右子树的时候我们按照同样的方式遍历，直到遍历完整棵树。

输入：root = [1,null,2,3]
输出：[1,3,2]

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
  const res = [];
  const inorder = (root) => {
      if (!root) {
          return;
      }
      inorder(root.left);
      res.push(root.val);
      inorder(root.right);
  }
  inorder(root);
  return res;
};
```

**前(先)序遍历**

前序遍历：若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子书。

特点：①. 根----->左------->右

​     ②. 根据前序遍历的结果可知第一个访问的必定是root结点。

**中序遍历**

中序遍历：若二叉树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树。

特点：①. 左----->根------->右

 	②. 根据中序遍历的结果，再结合前序遍历的root结点去划分root结点的左右子树。

**后序遍历**

后序遍历：若二叉树为空，则空操作返回，否则从左到右先叶子结点后结点的方式遍历访问左右子树，最后访问根结点。

特点：①. 左------>右------>根

​     ②. 根据后序遍历的结果可知最后访问的必定是root结点。

**层序遍历**

层序遍历：若二叉树为空，则空返回，否则从树的第一层，即根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。

特点：①. 从左到右，从上到下

​     ②. 可知第一个访问的必定是root结点

