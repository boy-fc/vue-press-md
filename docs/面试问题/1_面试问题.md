### 面试问题汇总

#### CSS

##### 1.flex布局一个第一行3列，第二行2列

##### 2.grid布局

##### 3.瀑布流

##### 4.css实现垂直居中（3种）

1. flex

```css
.parent {
  height: 400px;
  display: flex;
  align-items: center;
}
```

2. absolute + translate -50%

```css
.parent {
  height: 400px;
  position: relative;
}

.child {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}
```

3. absolute + 负 margin

```css
.parent {
  height: 400px;
  position: relative;
}

.child {
  width: 300px;
  height: 200px;
  position: absolute;
  left: 50%;
  top: 50%;
  margin-left: -150px;    /* 子元素 width 的一半 */
  margin-top: -100px;     /* 子元素 height 的一半 */
}
```

4. absolute + margin: auto

```css
.parent {
  height: 400px;
  position: relative;
}

.child {
  width: 300px;
  height: 200px;
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  margin: auto;
}
```

5. table 标签

```js
<table>
    <tr>
        <td>
            Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempora harum voluptates quae velit eveniet, accusamus, quas ratione placeat! Nisi perferendis facere, error sed possimus molestias et. Quas accusantium, maiores aliquid?
        </td>
    </tr>
</table>

```

6. div 模仿 table

```css
.parent {
  height: 400px;
  display: table;
}

.child {
  display: table-cell;
  vertical-align: middle;
}
```

7. 高度为 100% 的伪元素 + display: inline-block

```css
.parent {
  height: 400px;
  text-align: center;
}

.parent:before,
.parent:after {
  content: "";
  display: inline-block;
  height: 100%;            /* 前后伪元素高度 100% */
  vertical-align: middle;  /* 伪元素垂直居中 */
}

.child {
  width: 300px;
  display: inline-block;
  vertical-align: middle;  /* 子元素在 100% 高度中垂直居中 */
}
```

#### JS

##### 1.分片上传底层原理

**Blob**对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成 ReadableStream 来用于数据操作。

File接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。

**Blob.slice()**

返回一个新的 Blob 对象，包含了源 Blob 对象中指定范围内的数据。和数组的slice方法类似，截取数组的内容，大文件切片就是基于此方法来切分。

##### 2.防抖节流

##### 3.原型和原型链

##### 4.事件冒泡和委托原理和应用

##### 5.数组深拷贝的实现方法

##### 6.var和let的区别

##### 7.原生ajax的过程实现

##### 8.eventloop事件轮循

##### 9.一个字符串，获取每个数字出现的次数

##### 10.一个字符串，获取连续出现的字符串

##### 11.数据的基本类型

##### 12.判断数据类型的方法

##### 13.Object.defineProperty和proxy的区别

##### 14.async await的用法、原理，await返回的是什么

##### 15.promise的用法及原理

##### 16.函数的柯里化及作用

##### 17.函数的执行流程

1. 为函数创建一个执行环境
2. 复制函数的 [[scopes]] 属性中的对象构建起执行环境的作用链域
3. 创建函数活动对象并推入执行环境作用链域的前端
4. 执行代码
5. 销毁执行环境和活动对象（闭包情况下活动对象仍被引用没被销毁）

##### 18.进程和线程的区别

做个简单的比喻：进程=火车，线程=车厢

- 线程在进程下行进（单纯的车厢无法运行）
- 一个进程可以包含多个线程（一辆火车可以有多个车厢）
- 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
- 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
- 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
- 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
- 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
- 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
- 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”

##### 19.执行器

##### 20.generater

##### 21.数组的create方法

##### 22.try catch 中可以捕捉错误的类型

##### 23.for of 和for in的区别

简单来说就是它们两者都可以用于遍历，不过`for in`遍历的是数组的索引（`index`），而`for of`遍历的是数组元素值（`value`）

```js
// for in
var obj = {a:1, b:2, c:3}
    
for (let key in obj) {
  console.log(key)
}
// a b c

//for of
const array1 = ['a', 'b', 'c']
 
for (const val of array1) {
  console.log(val)
}
// a b c
```



##### 24.new一个实例的执行流程

(1) 创建一个新对象；
(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） ；
(3) 执行构造函数中的代码（为这个新对象添加属性） ；
(4) 返回新对象。

#### VUE

##### 1.SPA首屏加载慢怎么解决

##### 2.key的作用及什么时候用index,什么是用id

##### 3.data为什么是函数

##### 4.diff算法

##### 5.数据双向绑定的原理

##### 6.强制更新视图的方法（2种以上）

##### 7.set和$set的区别

##### 8.vue3中setup 语法糖

##### 9.vue3的钩子函数

##### 10.vuex和paina的区别

##### 11.vuex的构成及属性

##### 12.$nextTick的原理

#### WEBPACK

##### 1.webpack执行流程

##### 2.loaders和plugins的区别、实现原理

##### 3.loaders的执行顺序

##### 4.webpack怎么优化代码

##### 5.rollup和webpack的区别，有什么优势

Webpack:

1. **代码分割**可以将你的 app 分割成许多个容易管理的分块，这些分块能够在用户使用你的 app 时按需加载。这意味着你的用户可以有更快的交互体验。因为访问那些没有使用代码分割的应用时，必须要等待整个应用都被下载并解析完成。当然，你**也可以**自己手动去进行代码分割，但是……总之，祝你好运。
2. **静态资源**的导入：图片、CSS 等静态资源可以直接导入到你的 app 中，就和其它的模块、节点一样能够进行依赖管理。因此，我们再也不用小心翼翼地将各个静态文件放在特定的文件夹中，然后再去用脚本给文件 URL 加上哈希串了。Webpack 已经帮你完成了这一切。

Rollup:

1. 它利用 ES2015 模块的巧妙设计，尽可能高效地构建精简且易分发的 JavaScript 库。而其它的模块打包器（包括 Webpack在内）都是通过将模块分别封装进函数中，然将这些函数通过能在浏览器中实现的 `require` 方法打包，最后依次处理这些函数。在你需要实现按需加载的时候，这种做法非常的方便，但是这样做引入了很多无关代码，比较浪费资源。当[你有很多模块要打包的时候，这种情况会变得更糟糕](https://link.juejin.cn?target=https%3A%2F%2Fnolanlawson.com%2F2016%2F08%2F15%2Fthe-cost-of-small-modules%2F)。
2. 代码分割是一个很棘手的问题，而 Rollup 并不能做到这一点。同样的，Rollup 也不支持模块热替换（HMR）。而且对于打算使用 Rollup 的人来说，还有一个最大的痛点：它通过[插件](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Frollup%2Frollup-plugin-commonjs)处理大多数 CommonJS 文件的时候，一些代码将无法被翻译为 ES2015。

#### GIT

##### 1.git相关命令

##### 2.git怎么合并单个文件

#### UNI-APP

##### 1.uni-app的钩子函数

1. [应用生命周期](https://uniapp.dcloud.io/collocation/frame/lifetime?id=应用生命周期)

| 函数名            | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| onLaunch          | 当`uni-app` 初始化完成时触发（全局只触发一次）               |
| onShow            | 当 `uni-app` 启动，或从后台进入前台显示                      |
| onHide            | 当 `uni-app` 从前台进入后台                                  |
| onUniNViewMessage | 对 `nvue` 页面发送的数据进行监听，可参考 [nvue 向 vue 通讯](https://uniapp.dcloud.io/use-weex?id=nvue-向-vue-通讯) |

2. [页面生命周期](https://uniapp.dcloud.io/collocation/frame/lifetime?id=页面生命周期)

| 函数名                              | 说明                                                         | 平台差异说明                                        | 最低版本 |
| ----------------------------------- | ------------------------------------------------------------ | --------------------------------------------------- | -------- |
| onLoad                              | 监听页面加载，其参数为上个页面传递的数据，参数类型为Object（用于页面传参），参考[示例](https://uniapp.dcloud.io/api/router?id=navigateto) |                                                     |          |
| onShow                              | 监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面 |                                                     |          |
| onReady                             | 监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发 |                                                     |          |
| onHide                              | 监听页面隐藏                                                 |                                                     |          |
| onUnload                            | 监听页面卸载                                                 |                                                     |          |
| onResize                            | 监听窗口尺寸变化                                             | 5+App、微信小程序                                   |          |
| onPullDownRefresh                   | 监听用户下拉动作，一般用于下拉刷新，参考[示例](https://uniapp.dcloud.io/api/ui/pulldown) |                                                     |          |
| onReachBottom                       | 页面滚动到底部的事件（不是scroll-view滚到底），常用于下拉下一页数据。具体见下方注意事项 |                                                     |          |
| onTabItemTap                        | 点击 tab 时触发，参数为Object，具体见下方注意事项            | 微信小程序、百度小程序、H5、5+App（自定义组件模式） |          |
| onShareAppMessage                   | 用户点击右上角分享                                           | 微信小程序、百度小程序、头条小程序、支付宝小程序    |          |
| onPageScroll                        | 监听页面滚动，参数为Object                                   |                                                     |          |
| onNavigationBarButtonTap            | 监听原生标题栏按钮点击事件，参数为Object                     | 5+ App、H5                                          |          |
| onBackPress                         | 监听页面返回，返回 event = {from:backbutton、 navigateBack} ，backbutton 表示来源是左上角返回按钮或 android 返回键；navigateBack表示来源是 uni.navigateBack ；详细说明及使用：[onBackPress 详解](http://ask.dcloud.net.cn/article/35120) | 5+App、H5                                           |          |
| onNavigationBarSearchInputChanged   | 监听原生标题栏搜索输入框输入内容变化事件                     | 5+App、H5                                           | 1.6.0    |
| onNavigationBarSearchInputConfirmed | 监听原生标题栏搜索输入框搜索事件，用户点击软键盘上的“搜索”按钮时触发。 | 5+App、H5                                           | 1.6.0    |
| onNavigationBarSearchInputClicked   | 监听原生标题栏搜索输入框点击事件                             | 5+App、H5                                           | 1.6.0    |

#### 自动化测试

##### 1.说说单元测试



















































